/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/snabbdom/build/h.js":
/*!******************************************!*\
  !*** ./node_modules/snabbdom/build/h.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNS: () => (/* binding */ addNS),\n/* harmony export */   fragment: () => (/* binding */ fragment),\n/* harmony export */   h: () => (/* binding */ h)\n/* harmony export */ });\n/* harmony import */ var _vnode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vnode */ \"./node_modules/snabbdom/build/vnode.js\");\n/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ \"./node_modules/snabbdom/build/is.js\");\n\n\nfunction addNS(data, children, sel) {\n    data.ns = \"http://www.w3.org/2000/svg\";\n    if (sel !== \"foreignObject\" && children !== undefined) {\n        for (let i = 0; i < children.length; ++i) {\n            const child = children[i];\n            if (typeof child === \"string\")\n                continue;\n            const childData = child.data;\n            if (childData !== undefined) {\n                addNS(childData, child.children, child.sel);\n            }\n        }\n    }\n}\nfunction h(sel, b, c) {\n    let data = {};\n    let children;\n    let text;\n    let i;\n    if (c !== undefined) {\n        if (b !== null) {\n            data = b;\n        }\n        if (_is__WEBPACK_IMPORTED_MODULE_0__.array(c)) {\n            children = c;\n        }\n        else if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(c)) {\n            text = c.toString();\n        }\n        else if (c && c.sel) {\n            children = [c];\n        }\n    }\n    else if (b !== undefined && b !== null) {\n        if (_is__WEBPACK_IMPORTED_MODULE_0__.array(b)) {\n            children = b;\n        }\n        else if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(b)) {\n            text = b.toString();\n        }\n        else if (b && b.sel) {\n            children = [b];\n        }\n        else {\n            data = b;\n        }\n    }\n    if (children !== undefined) {\n        for (i = 0; i < children.length; ++i) {\n            if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(children[i]))\n                children[i] = (0,_vnode__WEBPACK_IMPORTED_MODULE_1__.vnode)(undefined, undefined, undefined, children[i], undefined);\n        }\n    }\n    if (sel[0] === \"s\" &&\n        sel[1] === \"v\" &&\n        sel[2] === \"g\" &&\n        (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) {\n        addNS(data, children, sel);\n    }\n    return (0,_vnode__WEBPACK_IMPORTED_MODULE_1__.vnode)(sel, data, children, text, undefined);\n}\n/**\n * @experimental\n */\nfunction fragment(children) {\n    let c;\n    let text;\n    if (_is__WEBPACK_IMPORTED_MODULE_0__.array(children)) {\n        c = children;\n    }\n    else if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(c)) {\n        text = children;\n    }\n    else if (c && c.sel) {\n        c = [children];\n    }\n    if (c !== undefined) {\n        for (let i = 0; i < c.length; ++i) {\n            if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(c[i]))\n                c[i] = (0,_vnode__WEBPACK_IMPORTED_MODULE_1__.vnode)(undefined, undefined, undefined, c[i], undefined);\n        }\n    }\n    return (0,_vnode__WEBPACK_IMPORTED_MODULE_1__.vnode)(undefined, {}, c, text, undefined);\n}\n//# sourceMappingURL=h.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/h.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/helpers/attachto.js":
/*!*********************************************************!*\
  !*** ./node_modules/snabbdom/build/helpers/attachto.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attachTo: () => (/* binding */ attachTo)\n/* harmony export */ });\nfunction pre(vnode, newVnode) {\n    const attachData = vnode.data.attachData;\n    // Copy created placeholder and real element from old vnode\n    newVnode.data.attachData.placeholder = attachData.placeholder;\n    newVnode.data.attachData.real = attachData.real;\n    // Mount real element in vnode so the patch process operates on it\n    vnode.elm = vnode.data.attachData.real;\n}\nfunction post(_, vnode) {\n    // Mount dummy placeholder in vnode so potential reorders use it\n    vnode.elm = vnode.data.attachData.placeholder;\n}\nfunction destroy(vnode) {\n    // Remove placeholder\n    if (vnode.elm !== undefined) {\n        vnode.elm.parentNode.removeChild(vnode.elm);\n    }\n    // Remove real element from where it was inserted\n    vnode.elm = vnode.data.attachData.real;\n}\nfunction create(_, vnode) {\n    const real = vnode.elm;\n    const attachData = vnode.data.attachData;\n    const placeholder = document.createElement(\"span\");\n    // Replace actual element with dummy placeholder\n    // Snabbdom will then insert placeholder instead\n    vnode.elm = placeholder;\n    attachData.target.appendChild(real);\n    attachData.real = real;\n    attachData.placeholder = placeholder;\n}\nfunction attachTo(target, vnode) {\n    if (vnode.data === undefined)\n        vnode.data = {};\n    if (vnode.data.hook === undefined)\n        vnode.data.hook = {};\n    const data = vnode.data;\n    const hook = vnode.data.hook;\n    data.attachData = { target: target, placeholder: undefined, real: undefined };\n    hook.create = create;\n    hook.prepatch = pre;\n    hook.postpatch = post;\n    hook.destroy = destroy;\n    return vnode;\n}\n//# sourceMappingURL=attachto.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/helpers/attachto.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/htmldomapi.js":
/*!***************************************************!*\
  !*** ./node_modules/snabbdom/build/htmldomapi.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   htmlDomApi: () => (/* binding */ htmlDomApi)\n/* harmony export */ });\nfunction createElement(tagName, options) {\n    return document.createElement(tagName, options);\n}\nfunction createElementNS(namespaceURI, qualifiedName, options) {\n    return document.createElementNS(namespaceURI, qualifiedName, options);\n}\nfunction createDocumentFragment() {\n    return parseFragment(document.createDocumentFragment());\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    if (isDocumentFragment(parentNode)) {\n        let node = parentNode;\n        while (node && isDocumentFragment(node)) {\n            const fragment = parseFragment(node);\n            node = fragment.parent;\n        }\n        parentNode = node !== null && node !== void 0 ? node : parentNode;\n    }\n    if (isDocumentFragment(newNode)) {\n        newNode = parseFragment(newNode, parentNode);\n    }\n    if (referenceNode && isDocumentFragment(referenceNode)) {\n        referenceNode = parseFragment(referenceNode).firstChildNode;\n    }\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    if (isDocumentFragment(child)) {\n        child = parseFragment(child, node);\n    }\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    if (isDocumentFragment(node)) {\n        while (node && isDocumentFragment(node)) {\n            const fragment = parseFragment(node);\n            node = fragment.parent;\n        }\n        return node !== null && node !== void 0 ? node : null;\n    }\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    var _a;\n    if (isDocumentFragment(node)) {\n        const fragment = parseFragment(node);\n        const parent = parentNode(fragment);\n        if (parent && fragment.lastChildNode) {\n            const children = Array.from(parent.childNodes);\n            const index = children.indexOf(fragment.lastChildNode);\n            return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;\n        }\n        return null;\n    }\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nfunction isDocumentFragment(node) {\n    return node.nodeType === 11;\n}\nfunction parseFragment(fragmentNode, parentNode) {\n    var _a, _b, _c;\n    const fragment = fragmentNode;\n    (_a = fragment.parent) !== null && _a !== void 0 ? _a : (fragment.parent = parentNode !== null && parentNode !== void 0 ? parentNode : null);\n    (_b = fragment.firstChildNode) !== null && _b !== void 0 ? _b : (fragment.firstChildNode = fragmentNode.firstChild);\n    (_c = fragment.lastChildNode) !== null && _c !== void 0 ? _c : (fragment.lastChildNode = fragmentNode.lastChild);\n    return fragment;\n}\nconst htmlDomApi = {\n    createElement,\n    createElementNS,\n    createTextNode,\n    createDocumentFragment,\n    createComment,\n    insertBefore,\n    removeChild,\n    appendChild,\n    parentNode,\n    nextSibling,\n    tagName,\n    setTextContent,\n    getTextContent,\n    isElement,\n    isText,\n    isComment,\n    isDocumentFragment,\n};\n//# sourceMappingURL=htmldomapi.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/htmldomapi.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/index.js":
/*!**********************************************!*\
  !*** ./node_modules/snabbdom/build/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fragment: () => (/* reexport safe */ _jsx__WEBPACK_IMPORTED_MODULE_14__.Fragment),\n/* harmony export */   array: () => (/* reexport safe */ _is__WEBPACK_IMPORTED_MODULE_5__.array),\n/* harmony export */   attachTo: () => (/* reexport safe */ _helpers_attachto__WEBPACK_IMPORTED_MODULE_4__.attachTo),\n/* harmony export */   attributesModule: () => (/* reexport safe */ _modules_attributes__WEBPACK_IMPORTED_MODULE_8__.attributesModule),\n/* harmony export */   classModule: () => (/* reexport safe */ _modules_class__WEBPACK_IMPORTED_MODULE_9__.classModule),\n/* harmony export */   datasetModule: () => (/* reexport safe */ _modules_dataset__WEBPACK_IMPORTED_MODULE_10__.datasetModule),\n/* harmony export */   eventListenersModule: () => (/* reexport safe */ _modules_eventlisteners__WEBPACK_IMPORTED_MODULE_11__.eventListenersModule),\n/* harmony export */   fragment: () => (/* reexport safe */ _h__WEBPACK_IMPORTED_MODULE_7__.fragment),\n/* harmony export */   h: () => (/* reexport safe */ _h__WEBPACK_IMPORTED_MODULE_7__.h),\n/* harmony export */   htmlDomApi: () => (/* reexport safe */ _htmldomapi__WEBPACK_IMPORTED_MODULE_0__.htmlDomApi),\n/* harmony export */   init: () => (/* reexport safe */ _init__WEBPACK_IMPORTED_MODULE_1__.init),\n/* harmony export */   jsx: () => (/* reexport safe */ _jsx__WEBPACK_IMPORTED_MODULE_14__.jsx),\n/* harmony export */   primitive: () => (/* reexport safe */ _is__WEBPACK_IMPORTED_MODULE_5__.primitive),\n/* harmony export */   propsModule: () => (/* reexport safe */ _modules_props__WEBPACK_IMPORTED_MODULE_12__.propsModule),\n/* harmony export */   styleModule: () => (/* reexport safe */ _modules_style__WEBPACK_IMPORTED_MODULE_13__.styleModule),\n/* harmony export */   thunk: () => (/* reexport safe */ _thunk__WEBPACK_IMPORTED_MODULE_2__.thunk),\n/* harmony export */   toVNode: () => (/* reexport safe */ _tovnode__WEBPACK_IMPORTED_MODULE_6__.toVNode),\n/* harmony export */   vnode: () => (/* reexport safe */ _vnode__WEBPACK_IMPORTED_MODULE_3__.vnode)\n/* harmony export */ });\n/* harmony import */ var _htmldomapi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./htmldomapi */ \"./node_modules/snabbdom/build/htmldomapi.js\");\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ \"./node_modules/snabbdom/build/init.js\");\n/* harmony import */ var _thunk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./thunk */ \"./node_modules/snabbdom/build/thunk.js\");\n/* harmony import */ var _vnode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vnode */ \"./node_modules/snabbdom/build/vnode.js\");\n/* harmony import */ var _helpers_attachto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/attachto */ \"./node_modules/snabbdom/build/helpers/attachto.js\");\n/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./is */ \"./node_modules/snabbdom/build/is.js\");\n/* harmony import */ var _tovnode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tovnode */ \"./node_modules/snabbdom/build/tovnode.js\");\n/* harmony import */ var _h__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./h */ \"./node_modules/snabbdom/build/h.js\");\n/* harmony import */ var _modules_attributes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/attributes */ \"./node_modules/snabbdom/build/modules/attributes.js\");\n/* harmony import */ var _modules_class__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/class */ \"./node_modules/snabbdom/build/modules/class.js\");\n/* harmony import */ var _modules_dataset__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/dataset */ \"./node_modules/snabbdom/build/modules/dataset.js\");\n/* harmony import */ var _modules_eventlisteners__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/eventlisteners */ \"./node_modules/snabbdom/build/modules/eventlisteners.js\");\n/* harmony import */ var _modules_props__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/props */ \"./node_modules/snabbdom/build/modules/props.js\");\n/* harmony import */ var _modules_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/style */ \"./node_modules/snabbdom/build/modules/style.js\");\n/* harmony import */ var _jsx__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./jsx */ \"./node_modules/snabbdom/build/jsx.js\");\n// core\n\n\n\n\n// helpers\n\n\n\n\n// types\n\n// modules\n\n\n\n\n\n\n// JSX\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/index.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/init.js":
/*!*********************************************!*\
  !*** ./node_modules/snabbdom/build/init.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\n/* harmony import */ var _vnode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vnode */ \"./node_modules/snabbdom/build/vnode.js\");\n/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is */ \"./node_modules/snabbdom/build/is.js\");\n/* harmony import */ var _htmldomapi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./htmldomapi */ \"./node_modules/snabbdom/build/htmldomapi.js\");\n\n\n\nfunction isUndef(s) {\n    return s === undefined;\n}\nfunction isDef(s) {\n    return s !== undefined;\n}\nconst emptyNode = (0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(\"\", {}, [], undefined, undefined);\nfunction sameVnode(vnode1, vnode2) {\n    var _a, _b;\n    const isSameKey = vnode1.key === vnode2.key;\n    const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);\n    const isSameSel = vnode1.sel === vnode2.sel;\n    const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel\n        ? typeof vnode1.text === typeof vnode2.text\n        : true;\n    return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;\n}\n/**\n * @todo Remove this function when the document fragment is considered stable.\n */\nfunction documentFragmentIsNotSupported() {\n    throw new Error(\"The document fragment is not supported on this platform.\");\n}\nfunction isElement(api, vnode) {\n    return api.isElement(vnode);\n}\nfunction isDocumentFragment(api, vnode) {\n    return api.isDocumentFragment(vnode);\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var _a;\n    const map = {};\n    for (let i = beginIdx; i <= endIdx; ++i) {\n        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;\n        if (key !== undefined) {\n            map[key] = i;\n        }\n    }\n    return map;\n}\nconst hooks = [\n    \"create\",\n    \"update\",\n    \"remove\",\n    \"destroy\",\n    \"pre\",\n    \"post\",\n];\nfunction init(modules, domApi, options) {\n    const cbs = {\n        create: [],\n        update: [],\n        remove: [],\n        destroy: [],\n        pre: [],\n        post: [],\n    };\n    const api = domApi !== undefined ? domApi : _htmldomapi__WEBPACK_IMPORTED_MODULE_1__.htmlDomApi;\n    for (const hook of hooks) {\n        for (const module of modules) {\n            const currentHook = module[hook];\n            if (currentHook !== undefined) {\n                cbs[hook].push(currentHook);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        const id = elm.id ? \"#\" + elm.id : \"\";\n        // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n        // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n        const classes = elm.getAttribute(\"class\");\n        const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function emptyDocumentFragmentAt(frag) {\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(undefined, {}, [], undefined, frag);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                const parent = api.parentNode(childElm);\n                api.removeChild(parent, childElm);\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d;\n        let i;\n        let data = vnode.data;\n        if (data !== undefined) {\n            const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;\n            if (isDef(init)) {\n                init(vnode);\n                data = vnode.data;\n            }\n        }\n        const children = vnode.children;\n        const sel = vnode.sel;\n        if (sel === \"!\") {\n            if (isUndef(vnode.text)) {\n                vnode.text = \"\";\n            }\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            const hashIdx = sel.indexOf(\"#\");\n            const dotIdx = sel.indexOf(\".\", hashIdx);\n            const hash = hashIdx > 0 ? hashIdx : sel.length;\n            const dot = dotIdx > 0 ? dotIdx : sel.length;\n            const tag = hashIdx !== -1 || dotIdx !== -1\n                ? sel.slice(0, Math.min(hash, dot))\n                : sel;\n            const elm = (vnode.elm =\n                isDef(data) && isDef((i = data.ns))\n                    ? api.createElementNS(i, tag, data)\n                    : api.createElement(tag, data));\n            if (hash < dot)\n                elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n            if (dotIdx > 0)\n                elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            if (_is__WEBPACK_IMPORTED_MODULE_2__.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    const ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            else if (_is__WEBPACK_IMPORTED_MODULE_2__.primitive(vnode.text)) {\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            const hook = vnode.data.hook;\n            if (isDef(hook)) {\n                (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode);\n                if (hook.insert) {\n                    insertedVnodeQueue.push(vnode);\n                }\n            }\n        }\n        else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode.children) {\n            vnode.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            for (i = 0; i < vnode.children.length; ++i) {\n                const ch = vnode.children[i];\n                if (ch != null) {\n                    api.appendChild(vnode.elm, createElm(ch, insertedVnodeQueue));\n                }\n            }\n        }\n        else {\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var _a, _b;\n        const data = vnode.data;\n        if (data !== undefined) {\n            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode);\n            for (let i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) {\n                for (let j = 0; j < vnode.children.length; ++j) {\n                    const child = vnode.children[j];\n                    if (child != null && typeof child !== \"string\") {\n                        invokeDestroyHook(child);\n                    }\n                }\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        var _a, _b;\n        for (; startIdx <= endIdx; ++startIdx) {\n            let listeners;\n            let rm;\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                if (isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for (let i = 0; i < cbs.remove.length; ++i)\n                        cbs.remove[i](ch, rm);\n                    const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;\n                    if (isDef(removeHook)) {\n                        removeHook(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else if (ch.children) {\n                    // Fragment node\n                    invokeDestroyHook(ch);\n                    removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);\n                }\n                else {\n                    // Text node\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        let oldStartIdx = 0;\n        let newStartIdx = 0;\n        let oldEndIdx = oldCh.length - 1;\n        let oldStartVnode = oldCh[0];\n        let oldEndVnode = oldCh[oldEndIdx];\n        let newEndIdx = newCh.length - 1;\n        let newStartVnode = newCh[0];\n        let newEndVnode = newCh[newEndIdx];\n        let oldKeyToIdx;\n        let idxInOld;\n        let elmToMove;\n        let before;\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\n                // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\n                // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) {\n                    // New element\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                }\n                else {\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n        if (newStartIdx <= newEndIdx) {\n            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        }\n        if (oldStartIdx <= oldEndIdx) {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;\n        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode);\n        const elm = (vnode.elm = oldVnode.elm);\n        if (oldVnode === vnode)\n            return;\n        if (vnode.data !== undefined ||\n            (isDef(vnode.text) && vnode.text !== oldVnode.text)) {\n            (_c = vnode.data) !== null && _c !== void 0 ? _c : (vnode.data = {});\n            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : (oldVnode.data = {});\n            for (let i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            (_g = (_f = (_e = vnode.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode);\n        }\n        const oldCh = oldVnode.children;\n        const ch = vnode.children;\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, \"\");\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, \"\");\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            api.setTextContent(elm, vnode.text);\n        }\n        (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode);\n    }\n    return function patch(oldVnode, vnode) {\n        let i, elm, parent;\n        const insertedVnodeQueue = [];\n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (isElement(api, oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        else if (isDocumentFragment(api, oldVnode)) {\n            oldVnode = emptyDocumentFragmentAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\n//# sourceMappingURL=init.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/init.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/is.js":
/*!*******************************************!*\
  !*** ./node_modules/snabbdom/build/is.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   primitive: () => (/* binding */ primitive)\n/* harmony export */ });\nconst array = Array.isArray;\nfunction primitive(s) {\n    return (typeof s === \"string\" ||\n        typeof s === \"number\" ||\n        s instanceof String ||\n        s instanceof Number);\n}\n//# sourceMappingURL=is.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/is.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/jsx.js":
/*!********************************************!*\
  !*** ./node_modules/snabbdom/build/jsx.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   jsx: () => (/* binding */ jsx)\n/* harmony export */ });\n/* harmony import */ var _vnode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vnode */ \"./node_modules/snabbdom/build/vnode.js\");\n/* harmony import */ var _h__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./h */ \"./node_modules/snabbdom/build/h.js\");\n/* eslint-disable @typescript-eslint/no-namespace, import/export */\n\n\nfunction Fragment(data, ...children) {\n    const flatChildren = flattenAndFilter(children, []);\n    if (flatChildren.length === 1 &&\n        !flatChildren[0].sel &&\n        flatChildren[0].text) {\n        // only child is a simple text node, pass as text for a simpler vtree\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(undefined, undefined, undefined, flatChildren[0].text, undefined);\n    }\n    else {\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(undefined, data !== null && data !== void 0 ? data : {}, flatChildren, undefined, undefined);\n    }\n}\nfunction flattenAndFilter(children, flattened) {\n    for (const child of children) {\n        // filter out falsey children, except 0 since zero can be a valid value e.g inside a chart\n        if (child !== undefined &&\n            child !== null &&\n            child !== false &&\n            child !== \"\") {\n            if (Array.isArray(child)) {\n                flattenAndFilter(child, flattened);\n            }\n            else if (typeof child === \"string\" ||\n                typeof child === \"number\" ||\n                typeof child === \"boolean\") {\n                flattened.push((0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(undefined, undefined, undefined, String(child), undefined));\n            }\n            else {\n                flattened.push(child);\n            }\n        }\n    }\n    return flattened;\n}\n/**\n * jsx/tsx compatible factory function\n * see: https://www.typescriptlang.org/docs/handbook/jsx.html#factory-functions\n */\nfunction jsx(tag, data, ...children) {\n    const flatChildren = flattenAndFilter(children, []);\n    if (typeof tag === \"function\") {\n        // tag is a function component\n        return tag(data, flatChildren);\n    }\n    else {\n        if (flatChildren.length === 1 &&\n            !flatChildren[0].sel &&\n            flatChildren[0].text) {\n            // only child is a simple text node, pass as text for a simpler vtree\n            return (0,_h__WEBPACK_IMPORTED_MODULE_1__.h)(tag, data, flatChildren[0].text);\n        }\n        else {\n            return (0,_h__WEBPACK_IMPORTED_MODULE_1__.h)(tag, data, flatChildren);\n        }\n    }\n}\n(function (jsx) {\n})(jsx || (jsx = {}));\n//# sourceMappingURL=jsx.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/jsx.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/modules/attributes.js":
/*!***********************************************************!*\
  !*** ./node_modules/snabbdom/build/modules/attributes.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attributesModule: () => (/* binding */ attributesModule)\n/* harmony export */ });\nconst xlinkNS = \"http://www.w3.org/1999/xlink\";\nconst xmlNS = \"http://www.w3.org/XML/1998/namespace\";\nconst colonChar = 58;\nconst xChar = 120;\nfunction updateAttrs(oldVnode, vnode) {\n    let key;\n    const elm = vnode.elm;\n    let oldAttrs = oldVnode.data.attrs;\n    let attrs = vnode.data.attrs;\n    if (!oldAttrs && !attrs)\n        return;\n    if (oldAttrs === attrs)\n        return;\n    oldAttrs = oldAttrs || {};\n    attrs = attrs || {};\n    // update modified attributes, add new attributes\n    for (key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            if (cur === true) {\n                elm.setAttribute(key, \"\");\n            }\n            else if (cur === false) {\n                elm.removeAttribute(key);\n            }\n            else {\n                if (key.charCodeAt(0) !== xChar) {\n                    elm.setAttribute(key, cur);\n                }\n                else if (key.charCodeAt(3) === colonChar) {\n                    // Assume xml namespace\n                    elm.setAttributeNS(xmlNS, key, cur);\n                }\n                else if (key.charCodeAt(5) === colonChar) {\n                    // Assume xlink namespace\n                    elm.setAttributeNS(xlinkNS, key, cur);\n                }\n                else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n    }\n    // remove removed attributes\n    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n    // the other option is to remove all attributes with value == undefined\n    for (key in oldAttrs) {\n        if (!(key in attrs)) {\n            elm.removeAttribute(key);\n        }\n    }\n}\nconst attributesModule = {\n    create: updateAttrs,\n    update: updateAttrs,\n};\n//# sourceMappingURL=attributes.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/modules/attributes.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/modules/class.js":
/*!******************************************************!*\
  !*** ./node_modules/snabbdom/build/modules/class.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   classModule: () => (/* binding */ classModule)\n/* harmony export */ });\nfunction updateClass(oldVnode, vnode) {\n    let cur;\n    let name;\n    const elm = vnode.elm;\n    let oldClass = oldVnode.data.class;\n    let klass = vnode.data.class;\n    if (!oldClass && !klass)\n        return;\n    if (oldClass === klass)\n        return;\n    oldClass = oldClass || {};\n    klass = klass || {};\n    for (name in oldClass) {\n        if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {\n            // was `true` and now not provided\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        cur = klass[name];\n        if (cur !== oldClass[name]) {\n            elm.classList[cur ? \"add\" : \"remove\"](name);\n        }\n    }\n}\nconst classModule = { create: updateClass, update: updateClass };\n//# sourceMappingURL=class.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/modules/class.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/modules/dataset.js":
/*!********************************************************!*\
  !*** ./node_modules/snabbdom/build/modules/dataset.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   datasetModule: () => (/* binding */ datasetModule)\n/* harmony export */ });\nconst CAPS_REGEX = /[A-Z]/g;\nfunction updateDataset(oldVnode, vnode) {\n    const elm = vnode.elm;\n    let oldDataset = oldVnode.data.dataset;\n    let dataset = vnode.data.dataset;\n    let key;\n    if (!oldDataset && !dataset)\n        return;\n    if (oldDataset === dataset)\n        return;\n    oldDataset = oldDataset || {};\n    dataset = dataset || {};\n    const d = elm.dataset;\n    for (key in oldDataset) {\n        if (!dataset[key]) {\n            if (d) {\n                if (key in d) {\n                    delete d[key];\n                }\n            }\n            else {\n                elm.removeAttribute(\"data-\" + key.replace(CAPS_REGEX, \"-$&\").toLowerCase());\n            }\n        }\n    }\n    for (key in dataset) {\n        if (oldDataset[key] !== dataset[key]) {\n            if (d) {\n                d[key] = dataset[key];\n            }\n            else {\n                elm.setAttribute(\"data-\" + key.replace(CAPS_REGEX, \"-$&\").toLowerCase(), dataset[key]);\n            }\n        }\n    }\n}\nconst datasetModule = {\n    create: updateDataset,\n    update: updateDataset,\n};\n//# sourceMappingURL=dataset.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/modules/dataset.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/modules/eventlisteners.js":
/*!***************************************************************!*\
  !*** ./node_modules/snabbdom/build/modules/eventlisteners.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventListenersModule: () => (/* binding */ eventListenersModule)\n/* harmony export */ });\nfunction invokeHandler(handler, vnode, event) {\n    if (typeof handler === \"function\") {\n        // call function handler\n        handler.call(vnode, event, vnode);\n    }\n    else if (typeof handler === \"object\") {\n        // call multiple handlers\n        for (let i = 0; i < handler.length; i++) {\n            invokeHandler(handler[i], vnode, event);\n        }\n    }\n}\nfunction handleEvent(event, vnode) {\n    const name = event.type;\n    const on = vnode.data.on;\n    // call event handler(s) if exists\n    if (on && on[name]) {\n        invokeHandler(on[name], vnode, event);\n    }\n}\nfunction createListener() {\n    return function handler(event) {\n        handleEvent(event, handler.vnode);\n    };\n}\nfunction updateEventListeners(oldVnode, vnode) {\n    const oldOn = oldVnode.data.on;\n    const oldListener = oldVnode.listener;\n    const oldElm = oldVnode.elm;\n    const on = vnode && vnode.data.on;\n    const elm = (vnode && vnode.elm);\n    let name;\n    // optimization for reused immutable handlers\n    if (oldOn === on) {\n        return;\n    }\n    // remove existing listeners which no longer used\n    if (oldOn && oldListener) {\n        // if element changed or deleted we remove all existing listeners unconditionally\n        if (!on) {\n            for (name in oldOn) {\n                // remove listener if element was changed or existing listeners removed\n                oldElm.removeEventListener(name, oldListener, false);\n            }\n        }\n        else {\n            for (name in oldOn) {\n                // remove listener if existing listener removed\n                if (!on[name]) {\n                    oldElm.removeEventListener(name, oldListener, false);\n                }\n            }\n        }\n    }\n    // add new listeners which has not already attached\n    if (on) {\n        // reuse existing listener or create new\n        const listener = (vnode.listener =\n            oldVnode.listener || createListener());\n        // update vnode for listener\n        listener.vnode = vnode;\n        // if element changed or added we add all needed listeners unconditionally\n        if (!oldOn) {\n            for (name in on) {\n                // add listener if element was changed or new listeners added\n                elm.addEventListener(name, listener, false);\n            }\n        }\n        else {\n            for (name in on) {\n                // add listener if new listener added\n                if (!oldOn[name]) {\n                    elm.addEventListener(name, listener, false);\n                }\n            }\n        }\n    }\n}\nconst eventListenersModule = {\n    create: updateEventListeners,\n    update: updateEventListeners,\n    destroy: updateEventListeners,\n};\n//# sourceMappingURL=eventlisteners.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/modules/eventlisteners.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/modules/props.js":
/*!******************************************************!*\
  !*** ./node_modules/snabbdom/build/modules/props.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   propsModule: () => (/* binding */ propsModule)\n/* harmony export */ });\nfunction updateProps(oldVnode, vnode) {\n    let key;\n    let cur;\n    let old;\n    const elm = vnode.elm;\n    let oldProps = oldVnode.data.props;\n    let props = vnode.data.props;\n    if (!oldProps && !props)\n        return;\n    if (oldProps === props)\n        return;\n    oldProps = oldProps || {};\n    props = props || {};\n    for (key in props) {\n        cur = props[key];\n        old = oldProps[key];\n        if (old !== cur && (key !== \"value\" || elm[key] !== cur)) {\n            elm[key] = cur;\n        }\n    }\n}\nconst propsModule = { create: updateProps, update: updateProps };\n//# sourceMappingURL=props.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/modules/props.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/modules/style.js":
/*!******************************************************!*\
  !*** ./node_modules/snabbdom/build/modules/style.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   styleModule: () => (/* binding */ styleModule)\n/* harmony export */ });\n// Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.\nconst raf = (typeof window !== \"undefined\" &&\n    window.requestAnimationFrame.bind(window)) ||\n    setTimeout;\nconst nextFrame = function (fn) {\n    raf(function () {\n        raf(fn);\n    });\n};\nlet reflowForced = false;\nfunction setNextFrame(obj, prop, val) {\n    nextFrame(function () {\n        obj[prop] = val;\n    });\n}\nfunction updateStyle(oldVnode, vnode) {\n    let cur;\n    let name;\n    const elm = vnode.elm;\n    let oldStyle = oldVnode.data.style;\n    let style = vnode.data.style;\n    if (!oldStyle && !style)\n        return;\n    if (oldStyle === style)\n        return;\n    oldStyle = oldStyle || {};\n    style = style || {};\n    const oldHasDel = \"delayed\" in oldStyle;\n    for (name in oldStyle) {\n        if (!style[name]) {\n            if (name[0] === \"-\" && name[1] === \"-\") {\n                elm.style.removeProperty(name);\n            }\n            else {\n                elm.style[name] = \"\";\n            }\n        }\n    }\n    for (name in style) {\n        cur = style[name];\n        if (name === \"delayed\" && style.delayed) {\n            for (const name2 in style.delayed) {\n                cur = style.delayed[name2];\n                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {\n                    setNextFrame(elm.style, name2, cur);\n                }\n            }\n        }\n        else if (name !== \"remove\" && cur !== oldStyle[name]) {\n            if (name[0] === \"-\" && name[1] === \"-\") {\n                elm.style.setProperty(name, cur);\n            }\n            else {\n                elm.style[name] = cur;\n            }\n        }\n    }\n}\nfunction applyDestroyStyle(vnode) {\n    let style;\n    let name;\n    const elm = vnode.elm;\n    const s = vnode.data.style;\n    if (!s || !(style = s.destroy))\n        return;\n    for (name in style) {\n        elm.style[name] = style[name];\n    }\n}\nfunction applyRemoveStyle(vnode, rm) {\n    const s = vnode.data.style;\n    if (!s || !s.remove) {\n        rm();\n        return;\n    }\n    if (!reflowForced) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        vnode.elm.offsetLeft;\n        reflowForced = true;\n    }\n    let name;\n    const elm = vnode.elm;\n    let i = 0;\n    const style = s.remove;\n    let amount = 0;\n    const applied = [];\n    for (name in style) {\n        applied.push(name);\n        elm.style[name] = style[name];\n    }\n    const compStyle = getComputedStyle(elm);\n    const props = compStyle[\"transition-property\"].split(\", \");\n    for (; i < props.length; ++i) {\n        if (applied.indexOf(props[i]) !== -1)\n            amount++;\n    }\n    elm.addEventListener(\"transitionend\", function (ev) {\n        if (ev.target === elm)\n            --amount;\n        if (amount === 0)\n            rm();\n    });\n}\nfunction forceReflow() {\n    reflowForced = false;\n}\nconst styleModule = {\n    pre: forceReflow,\n    create: updateStyle,\n    update: updateStyle,\n    destroy: applyDestroyStyle,\n    remove: applyRemoveStyle,\n};\n//# sourceMappingURL=style.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/modules/style.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/thunk.js":
/*!**********************************************!*\
  !*** ./node_modules/snabbdom/build/thunk.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thunk: () => (/* binding */ thunk)\n/* harmony export */ });\n/* harmony import */ var _h__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./h */ \"./node_modules/snabbdom/build/h.js\");\n\nfunction copyToThunk(vnode, thunk) {\n    var _a;\n    const ns = (_a = thunk.data) === null || _a === void 0 ? void 0 : _a.ns;\n    vnode.data.fn = thunk.data.fn;\n    vnode.data.args = thunk.data.args;\n    thunk.data = vnode.data;\n    thunk.children = vnode.children;\n    thunk.text = vnode.text;\n    thunk.elm = vnode.elm;\n    if (ns)\n        (0,_h__WEBPACK_IMPORTED_MODULE_0__.addNS)(thunk.data, thunk.children, thunk.sel);\n}\nfunction init(thunk) {\n    const cur = thunk.data;\n    const vnode = cur.fn(...cur.args);\n    copyToThunk(vnode, thunk);\n}\nfunction prepatch(oldVnode, thunk) {\n    let i;\n    const old = oldVnode.data;\n    const cur = thunk.data;\n    const oldArgs = old.args;\n    const args = cur.args;\n    if (old.fn !== cur.fn || oldArgs.length !== args.length) {\n        copyToThunk(cur.fn(...args), thunk);\n        return;\n    }\n    for (i = 0; i < args.length; ++i) {\n        if (oldArgs[i] !== args[i]) {\n            copyToThunk(cur.fn(...args), thunk);\n            return;\n        }\n    }\n    copyToThunk(oldVnode, thunk);\n}\nconst thunk = function thunk(sel, key, fn, args) {\n    if (args === undefined) {\n        args = fn;\n        fn = key;\n        key = undefined;\n    }\n    return (0,_h__WEBPACK_IMPORTED_MODULE_0__.h)(sel, {\n        key: key,\n        hook: { init, prepatch },\n        fn: fn,\n        args: args,\n    });\n};\n//# sourceMappingURL=thunk.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/thunk.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/tovnode.js":
/*!************************************************!*\
  !*** ./node_modules/snabbdom/build/tovnode.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toVNode: () => (/* binding */ toVNode)\n/* harmony export */ });\n/* harmony import */ var _h__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./h */ \"./node_modules/snabbdom/build/h.js\");\n/* harmony import */ var _vnode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vnode */ \"./node_modules/snabbdom/build/vnode.js\");\n/* harmony import */ var _htmldomapi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./htmldomapi */ \"./node_modules/snabbdom/build/htmldomapi.js\");\n\n\n\nfunction toVNode(node, domApi) {\n    const api = domApi !== undefined ? domApi : _htmldomapi__WEBPACK_IMPORTED_MODULE_0__.htmlDomApi;\n    let text;\n    if (api.isElement(node)) {\n        const id = node.id ? \"#\" + node.id : \"\";\n        const cn = node.getAttribute(\"class\");\n        const c = cn ? \".\" + cn.split(\" \").join(\".\") : \"\";\n        const sel = api.tagName(node).toLowerCase() + id + c;\n        const attrs = {};\n        const dataset = {};\n        const data = {};\n        const children = [];\n        let name;\n        let i, n;\n        const elmAttrs = node.attributes;\n        const elmChildren = node.childNodes;\n        for (i = 0, n = elmAttrs.length; i < n; i++) {\n            name = elmAttrs[i].nodeName;\n            if (name[0] === \"d\" &&\n                name[1] === \"a\" &&\n                name[2] === \"t\" &&\n                name[3] === \"a\" &&\n                name[4] === \"-\") {\n                dataset[name.slice(5)] = elmAttrs[i].nodeValue || \"\";\n            }\n            else if (name !== \"id\" && name !== \"class\") {\n                attrs[name] = elmAttrs[i].nodeValue;\n            }\n        }\n        for (i = 0, n = elmChildren.length; i < n; i++) {\n            children.push(toVNode(elmChildren[i], domApi));\n        }\n        if (Object.keys(attrs).length > 0)\n            data.attrs = attrs;\n        if (Object.keys(dataset).length > 0)\n            data.dataset = dataset;\n        if (sel[0] === \"s\" &&\n            sel[1] === \"v\" &&\n            sel[2] === \"g\" &&\n            (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) {\n            (0,_h__WEBPACK_IMPORTED_MODULE_1__.addNS)(data, children, sel);\n        }\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_2__.vnode)(sel, data, children, undefined, node);\n    }\n    else if (api.isText(node)) {\n        text = api.getTextContent(node);\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_2__.vnode)(undefined, undefined, undefined, text, node);\n    }\n    else if (api.isComment(node)) {\n        text = api.getTextContent(node);\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_2__.vnode)(\"!\", {}, [], text, node);\n    }\n    else {\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_2__.vnode)(\"\", {}, [], undefined, node);\n    }\n}\n//# sourceMappingURL=tovnode.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/tovnode.js?");

/***/ }),

/***/ "./node_modules/snabbdom/build/vnode.js":
/*!**********************************************!*\
  !*** ./node_modules/snabbdom/build/vnode.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vnode: () => (/* binding */ vnode)\n/* harmony export */ });\nfunction vnode(sel, data, children, text, elm) {\n    const key = data === undefined ? undefined : data.key;\n    return { sel, data, children, text, elm, key };\n}\n//# sourceMappingURL=vnode.js.map\n\n//# sourceURL=webpack://website/./node_modules/snabbdom/build/vnode.js?");

/***/ }),

/***/ "./src/chess-thing.ts":
/*!****************************!*\
  !*** ./src/chess-thing.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar chessground_1 = __webpack_require__(/*! chessground */ \"./node_modules/chessground/chessground.js\");\nvar config = {};\nvar ground = (0, chessground_1.Chessground)(document.getElementById('chessground'), config);\n\n\n//# sourceURL=webpack://website/./src/chess-thing.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__webpack_require__(/*! ./chess-thing.ts */ \"./src/chess-thing.ts\");\nvar snabbdom_1 = __webpack_require__(/*! snabbdom */ \"./node_modules/snabbdom/build/index.js\");\n// Initialize snabbdom\nvar patch = (0, snabbdom_1.init)([\n    // Init patch function with chosen modules\n    snabbdom_1.classModule,\n    snabbdom_1.propsModule,\n    snabbdom_1.styleModule,\n    snabbdom_1.eventListenersModule, // attaches event listeners\n]);\n// Create a variable to store the MediaRecorder object\nvar mediaRecorder = null;\nvar recording_number = 1;\nvar recording = null;\n// Get user's audio from the microphone\nwindow.onload = function () {\n    console.log('window loaded');\n    // get audio stream from user's mic\n    navigator.mediaDevices.getUserMedia({\n        audio: true\n    }).then(function (stream) {\n        mediaRecorder = new MediaRecorder(stream);\n        mediaRecorder.addEventListener('dataavailable', onRecordingReady);\n    }).catch(function (err) {\n        console.log('The following getUserMedia error occurred: ' + err);\n    });\n};\nvar start_recording = function (e) {\n    console.log('start recording');\n    if (!mediaRecorder) {\n        console.log('mediaRecorder is null');\n        return;\n    }\n    console.log(mediaRecorder);\n    mediaRecorder.start();\n};\nvar stop_recording = function (e) {\n    console.log('stop recording');\n    if (!mediaRecorder) {\n        console.log('mediaRecorder is null');\n        return;\n    }\n    mediaRecorder.stop();\n};\nvar download = function (url, name) {\n    var a = document.createElement('a');\n    a.href = url;\n    a.download = name;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n};\nvar onRecordingReady = function (e) {\n    // Logs the recording to the console\n    console.log(e);\n    // Creates a new recording\n    var name = \"recording-\".concat(recording_number++);\n    var url = URL.createObjectURL(e.data);\n    // Adds a button to download the recording\n    var downloadButton = (0, snabbdom_1.h)('button#download', { on: { click: function () { return download(url, name); } } }, 'Download');\n    patch(document.getElementById('download'), downloadButton);\n    // Saves blob to recording\n    recording = e.data;\n};\nvar send = function (e) {\n    console.log('send');\n    // Posts a wav file of blob recording to http://127.0.0.1:8004\n    if (!recording) {\n        console.log('recording is null');\n        return;\n    }\n    // Saves as an mp3\n    console.log('sending');\n    var formData = new FormData();\n    formData.append('file', recording, 'recording.wav');\n    fetch('http://127.0.0.1:8004/transcribe', {\n        method: 'POST',\n        body: formData\n    }).then(function (response) {\n        if (response.ok) {\n            console.log('Upload successful!');\n        }\n        else {\n            console.error('Upload failed!');\n        }\n    }).catch(function (error) { return console.error('Error:', error); });\n};\nvar start_node = (0, snabbdom_1.h)('button#start', { on: { click: start_recording } }, 'Start');\npatch(document.getElementById('start'), start_node);\n// changes button to start recording\nvar stop_node = (0, snabbdom_1.h)('button#stop', { on: { click: stop_recording } }, 'Stop');\npatch(document.getElementById('stop'), stop_node);\n\n\n//# sourceURL=webpack://website/./src/index.ts?");

/***/ }),

/***/ "./node_modules/chessground/anim.js":
/*!******************************************!*\
  !*** ./node_modules/chessground/anim.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anim: () => (/* binding */ anim),\n/* harmony export */   render: () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n\nconst anim = (mutation, state) => state.animation.enabled ? animate(mutation, state) : render(mutation, state);\nfunction render(mutation, state) {\n    const result = mutation(state);\n    state.dom.redraw();\n    return result;\n}\nconst makePiece = (key, piece) => ({\n    key: key,\n    pos: _util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos(key),\n    piece: piece,\n});\nconst closer = (piece, pieces) => pieces.sort((p1, p2) => _util_js__WEBPACK_IMPORTED_MODULE_0__.distanceSq(piece.pos, p1.pos) - _util_js__WEBPACK_IMPORTED_MODULE_0__.distanceSq(piece.pos, p2.pos))[0];\nfunction computePlan(prevPieces, current) {\n    const anims = new Map(), animedOrigs = [], fadings = new Map(), missings = [], news = [], prePieces = new Map();\n    let curP, preP, vector;\n    for (const [k, p] of prevPieces) {\n        prePieces.set(k, makePiece(k, p));\n    }\n    for (const key of _util_js__WEBPACK_IMPORTED_MODULE_0__.allKeys) {\n        curP = current.pieces.get(key);\n        preP = prePieces.get(key);\n        if (curP) {\n            if (preP) {\n                if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.samePiece(curP, preP.piece)) {\n                    missings.push(preP);\n                    news.push(makePiece(key, curP));\n                }\n            }\n            else\n                news.push(makePiece(key, curP));\n        }\n        else if (preP)\n            missings.push(preP);\n    }\n    for (const newP of news) {\n        preP = closer(newP, missings.filter(p => _util_js__WEBPACK_IMPORTED_MODULE_0__.samePiece(newP.piece, p.piece)));\n        if (preP) {\n            vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];\n            anims.set(newP.key, vector.concat(vector));\n            animedOrigs.push(preP.key);\n        }\n    }\n    for (const p of missings) {\n        if (!animedOrigs.includes(p.key))\n            fadings.set(p.key, p.piece);\n    }\n    return {\n        anims: anims,\n        fadings: fadings,\n    };\n}\nfunction step(state, now) {\n    const cur = state.animation.current;\n    if (cur === undefined) {\n        // animation was canceled :(\n        if (!state.dom.destroyed)\n            state.dom.redrawNow();\n        return;\n    }\n    const rest = 1 - (now - cur.start) * cur.frequency;\n    if (rest <= 0) {\n        state.animation.current = undefined;\n        state.dom.redrawNow();\n    }\n    else {\n        const ease = easing(rest);\n        for (const cfg of cur.plan.anims.values()) {\n            cfg[2] = cfg[0] * ease;\n            cfg[3] = cfg[1] * ease;\n        }\n        state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n        requestAnimationFrame((now = performance.now()) => step(state, now));\n    }\n}\nfunction animate(mutation, state) {\n    // clone state before mutating it\n    const prevPieces = new Map(state.pieces);\n    const result = mutation(state);\n    const plan = computePlan(prevPieces, state);\n    if (plan.anims.size || plan.fadings.size) {\n        const alreadyRunning = state.animation.current && state.animation.current.start;\n        state.animation.current = {\n            start: performance.now(),\n            frequency: 1 / state.animation.duration,\n            plan: plan,\n        };\n        if (!alreadyRunning)\n            step(state, performance.now());\n    }\n    else {\n        // don't animate, just render right away\n        state.dom.redraw();\n    }\n    return result;\n}\n// https://gist.github.com/gre/1650294\nconst easing = (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);\n//# sourceMappingURL=anim.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/anim.js?");

/***/ }),

/***/ "./node_modules/chessground/api.js":
/*!*****************************************!*\
  !*** ./node_modules/chessground/api.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   start: () => (/* binding */ start)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/chessground/board.js\");\n/* harmony import */ var _fen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fen.js */ \"./node_modules/chessground/fen.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.js */ \"./node_modules/chessground/config.js\");\n/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anim.js */ \"./node_modules/chessground/anim.js\");\n/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drag.js */ \"./node_modules/chessground/drag.js\");\n/* harmony import */ var _explosion_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./explosion.js */ \"./node_modules/chessground/explosion.js\");\n\n\n\n\n\n\n// see API types and documentations in dts/api.d.ts\nfunction start(state, redrawAll) {\n    function toggleOrientation() {\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.toggleOrientation(state);\n        redrawAll();\n    }\n    return {\n        set(config) {\n            if (config.orientation && config.orientation !== state.orientation)\n                toggleOrientation();\n            (0,_config_js__WEBPACK_IMPORTED_MODULE_2__.applyAnimation)(state, config);\n            (config.fen ? _anim_js__WEBPACK_IMPORTED_MODULE_3__.anim : _anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => (0,_config_js__WEBPACK_IMPORTED_MODULE_2__.configure)(state, config), state);\n        },\n        state,\n        getFen: () => (0,_fen_js__WEBPACK_IMPORTED_MODULE_1__.write)(state.pieces),\n        toggleOrientation,\n        setPieces(pieces) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.setPieces(state, pieces), state);\n        },\n        selectSquare(key, force) {\n            if (key)\n                (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.selectSquare(state, key, force), state);\n            else if (state.selected) {\n                _board_js__WEBPACK_IMPORTED_MODULE_0__.unselect(state);\n                state.dom.redraw();\n            }\n        },\n        move(orig, dest) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.baseMove(state, orig, dest), state);\n        },\n        newPiece(piece, key) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.baseNewPiece(state, piece, key), state);\n        },\n        playPremove() {\n            if (state.premovable.current) {\n                if ((0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(_board_js__WEBPACK_IMPORTED_MODULE_0__.playPremove, state))\n                    return true;\n                // if the premove couldn't be played, redraw to clear it up\n                state.dom.redraw();\n            }\n            return false;\n        },\n        playPredrop(validate) {\n            if (state.predroppable.current) {\n                const result = _board_js__WEBPACK_IMPORTED_MODULE_0__.playPredrop(state, validate);\n                state.dom.redraw();\n                return result;\n            }\n            return false;\n        },\n        cancelPremove() {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(_board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPremove, state);\n        },\n        cancelPredrop() {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(_board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPredrop, state);\n        },\n        cancelMove() {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => {\n                _board_js__WEBPACK_IMPORTED_MODULE_0__.cancelMove(state);\n                (0,_drag_js__WEBPACK_IMPORTED_MODULE_4__.cancel)(state);\n            }, state);\n        },\n        stop() {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => {\n                _board_js__WEBPACK_IMPORTED_MODULE_0__.stop(state);\n                (0,_drag_js__WEBPACK_IMPORTED_MODULE_4__.cancel)(state);\n            }, state);\n        },\n        explode(keys) {\n            (0,_explosion_js__WEBPACK_IMPORTED_MODULE_5__.explosion)(state, keys);\n        },\n        setAutoShapes(shapes) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => (state.drawable.autoShapes = shapes), state);\n        },\n        setShapes(shapes) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => (state.drawable.shapes = shapes), state);\n        },\n        getKeyAtDomPos(pos) {\n            return _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(pos, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(state), state.dom.bounds());\n        },\n        redrawAll,\n        dragNewPiece(piece, event, force) {\n            (0,_drag_js__WEBPACK_IMPORTED_MODULE_4__.dragNewPiece)(state, piece, event, force);\n        },\n        destroy() {\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.stop(state);\n            state.dom.unbind && state.dom.unbind();\n            state.dom.destroyed = true;\n        },\n    };\n}\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/api.js?");

/***/ }),

/***/ "./node_modules/chessground/autoPieces.js":
/*!************************************************!*\
  !*** ./node_modules/chessground/autoPieces.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   renderResized: () => (/* binding */ renderResized)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./node_modules/chessground/board.js\");\n/* harmony import */ var _sync_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sync.js */ \"./node_modules/chessground/sync.js\");\n\n\n\nfunction render(state, autoPieceEl) {\n    const autoPieces = state.drawable.autoShapes.filter(autoShape => autoShape.piece);\n    const autoPieceShapes = autoPieces.map((s) => {\n        return {\n            shape: s,\n            hash: hash(s),\n            current: false,\n        };\n    });\n    (0,_sync_js__WEBPACK_IMPORTED_MODULE_2__.syncShapes)(autoPieceShapes, autoPieceEl, shape => renderShape(state, shape, state.dom.bounds()));\n}\nfunction renderResized(state) {\n    var _a;\n    const asWhite = (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.whitePov)(state), posToTranslate = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.posToTranslate)(state.dom.bounds());\n    let el = (_a = state.dom.elements.autoPieces) === null || _a === void 0 ? void 0 : _a.firstChild;\n    while (el) {\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translateAndScale)(el, posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(el.cgKey), asWhite), el.cgScale);\n        el = el.nextSibling;\n    }\n}\nfunction renderShape(state, { shape, hash }, bounds) {\n    var _a, _b, _c;\n    const orig = shape.orig;\n    const role = (_a = shape.piece) === null || _a === void 0 ? void 0 : _a.role;\n    const color = (_b = shape.piece) === null || _b === void 0 ? void 0 : _b.color;\n    const scale = (_c = shape.piece) === null || _c === void 0 ? void 0 : _c.scale;\n    const pieceEl = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('piece', `${role} ${color}`);\n    pieceEl.setAttribute('cgHash', hash);\n    pieceEl.cgKey = orig;\n    pieceEl.cgScale = scale;\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translateAndScale)(pieceEl, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.posToTranslate)(bounds)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(orig), (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.whitePov)(state)), scale);\n    return pieceEl;\n}\nconst hash = (autoPiece) => { var _a, _b, _c; return [autoPiece.orig, (_a = autoPiece.piece) === null || _a === void 0 ? void 0 : _a.role, (_b = autoPiece.piece) === null || _b === void 0 ? void 0 : _b.color, (_c = autoPiece.piece) === null || _c === void 0 ? void 0 : _c.scale].join(','); };\n//# sourceMappingURL=autoPieces.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/autoPieces.js?");

/***/ }),

/***/ "./node_modules/chessground/board.js":
/*!*******************************************!*\
  !*** ./node_modules/chessground/board.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   baseMove: () => (/* binding */ baseMove),\n/* harmony export */   baseNewPiece: () => (/* binding */ baseNewPiece),\n/* harmony export */   callUserFunction: () => (/* binding */ callUserFunction),\n/* harmony export */   canMove: () => (/* binding */ canMove),\n/* harmony export */   cancelMove: () => (/* binding */ cancelMove),\n/* harmony export */   dropNewPiece: () => (/* binding */ dropNewPiece),\n/* harmony export */   getKeyAtDomPos: () => (/* binding */ getKeyAtDomPos),\n/* harmony export */   getSnappedKeyAtDomPos: () => (/* binding */ getSnappedKeyAtDomPos),\n/* harmony export */   isDraggable: () => (/* binding */ isDraggable),\n/* harmony export */   playPredrop: () => (/* binding */ playPredrop),\n/* harmony export */   playPremove: () => (/* binding */ playPremove),\n/* harmony export */   reset: () => (/* binding */ reset),\n/* harmony export */   selectSquare: () => (/* binding */ selectSquare),\n/* harmony export */   setCheck: () => (/* binding */ setCheck),\n/* harmony export */   setPieces: () => (/* binding */ setPieces),\n/* harmony export */   setSelected: () => (/* binding */ setSelected),\n/* harmony export */   stop: () => (/* binding */ stop),\n/* harmony export */   toggleOrientation: () => (/* binding */ toggleOrientation),\n/* harmony export */   unselect: () => (/* binding */ unselect),\n/* harmony export */   unsetPredrop: () => (/* binding */ unsetPredrop),\n/* harmony export */   unsetPremove: () => (/* binding */ unsetPremove),\n/* harmony export */   userMove: () => (/* binding */ userMove),\n/* harmony export */   whitePov: () => (/* binding */ whitePov)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n/* harmony import */ var _premove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./premove.js */ \"./node_modules/chessground/premove.js\");\n\n\nfunction callUserFunction(f, ...args) {\n    if (f)\n        setTimeout(() => f(...args), 1);\n}\nfunction toggleOrientation(state) {\n    state.orientation = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.opposite)(state.orientation);\n    state.animation.current = state.draggable.current = state.selected = undefined;\n}\nfunction reset(state) {\n    state.lastMove = undefined;\n    unselect(state);\n    unsetPremove(state);\n    unsetPredrop(state);\n}\nfunction setPieces(state, pieces) {\n    for (const [key, piece] of pieces) {\n        if (piece)\n            state.pieces.set(key, piece);\n        else\n            state.pieces.delete(key);\n    }\n}\nfunction setCheck(state, color) {\n    state.check = undefined;\n    if (color === true)\n        color = state.turnColor;\n    if (color)\n        for (const [k, p] of state.pieces) {\n            if (p.role === 'king' && p.color === color) {\n                state.check = k;\n            }\n        }\n}\nfunction setPremove(state, orig, dest, meta) {\n    unsetPredrop(state);\n    state.premovable.current = [orig, dest];\n    callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\nfunction unsetPremove(state) {\n    if (state.premovable.current) {\n        state.premovable.current = undefined;\n        callUserFunction(state.premovable.events.unset);\n    }\n}\nfunction setPredrop(state, role, key) {\n    unsetPremove(state);\n    state.predroppable.current = { role, key };\n    callUserFunction(state.predroppable.events.set, role, key);\n}\nfunction unsetPredrop(state) {\n    const pd = state.predroppable;\n    if (pd.current) {\n        pd.current = undefined;\n        callUserFunction(pd.events.unset);\n    }\n}\nfunction tryAutoCastle(state, orig, dest) {\n    if (!state.autoCastle)\n        return false;\n    const king = state.pieces.get(orig);\n    if (!king || king.role !== 'king')\n        return false;\n    const origPos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(orig);\n    const destPos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(dest);\n    if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1])\n        return false;\n    if (origPos[0] === 4 && !state.pieces.has(dest)) {\n        if (destPos[0] === 6)\n            dest = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([7, destPos[1]]);\n        else if (destPos[0] === 2)\n            dest = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([0, destPos[1]]);\n    }\n    const rook = state.pieces.get(dest);\n    if (!rook || rook.color !== king.color || rook.role !== 'rook')\n        return false;\n    state.pieces.delete(orig);\n    state.pieces.delete(dest);\n    if (origPos[0] < destPos[0]) {\n        state.pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([6, destPos[1]]), king);\n        state.pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([5, destPos[1]]), rook);\n    }\n    else {\n        state.pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([2, destPos[1]]), king);\n        state.pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([3, destPos[1]]), rook);\n    }\n    return true;\n}\nfunction baseMove(state, orig, dest) {\n    const origPiece = state.pieces.get(orig), destPiece = state.pieces.get(dest);\n    if (orig === dest || !origPiece)\n        return false;\n    const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n    if (dest === state.selected)\n        unselect(state);\n    callUserFunction(state.events.move, orig, dest, captured);\n    if (!tryAutoCastle(state, orig, dest)) {\n        state.pieces.set(dest, origPiece);\n        state.pieces.delete(orig);\n    }\n    state.lastMove = [orig, dest];\n    state.check = undefined;\n    callUserFunction(state.events.change);\n    return captured || true;\n}\nfunction baseNewPiece(state, piece, key, force) {\n    if (state.pieces.has(key)) {\n        if (force)\n            state.pieces.delete(key);\n        else\n            return false;\n    }\n    callUserFunction(state.events.dropNewPiece, piece, key);\n    state.pieces.set(key, piece);\n    state.lastMove = [key];\n    state.check = undefined;\n    callUserFunction(state.events.change);\n    state.movable.dests = undefined;\n    state.turnColor = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.opposite)(state.turnColor);\n    return true;\n}\nfunction baseUserMove(state, orig, dest) {\n    const result = baseMove(state, orig, dest);\n    if (result) {\n        state.movable.dests = undefined;\n        state.turnColor = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.opposite)(state.turnColor);\n        state.animation.current = undefined;\n    }\n    return result;\n}\nfunction userMove(state, orig, dest) {\n    if (canMove(state, orig, dest)) {\n        const result = baseUserMove(state, orig, dest);\n        if (result) {\n            const holdTime = state.hold.stop();\n            unselect(state);\n            const metadata = {\n                premove: false,\n                ctrlKey: state.stats.ctrlKey,\n                holdTime,\n            };\n            if (result !== true)\n                metadata.captured = result;\n            callUserFunction(state.movable.events.after, orig, dest, metadata);\n            return true;\n        }\n    }\n    else if (canPremove(state, orig, dest)) {\n        setPremove(state, orig, dest, {\n            ctrlKey: state.stats.ctrlKey,\n        });\n        unselect(state);\n        return true;\n    }\n    unselect(state);\n    return false;\n}\nfunction dropNewPiece(state, orig, dest, force) {\n    const piece = state.pieces.get(orig);\n    if (piece && (canDrop(state, orig, dest) || force)) {\n        state.pieces.delete(orig);\n        baseNewPiece(state, piece, dest, force);\n        callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n            premove: false,\n            predrop: false,\n        });\n    }\n    else if (piece && canPredrop(state, orig, dest)) {\n        setPredrop(state, piece.role, dest);\n    }\n    else {\n        unsetPremove(state);\n        unsetPredrop(state);\n    }\n    state.pieces.delete(orig);\n    unselect(state);\n}\nfunction selectSquare(state, key, force) {\n    callUserFunction(state.events.select, key);\n    if (state.selected) {\n        if (state.selected === key && !state.draggable.enabled) {\n            unselect(state);\n            state.hold.cancel();\n            return;\n        }\n        else if ((state.selectable.enabled || force) && state.selected !== key) {\n            if (userMove(state, state.selected, key)) {\n                state.stats.dragged = false;\n                return;\n            }\n        }\n    }\n    if ((state.selectable.enabled || state.draggable.enabled) && (isMovable(state, key) || isPremovable(state, key))) {\n        setSelected(state, key);\n        state.hold.start();\n    }\n}\nfunction setSelected(state, key) {\n    state.selected = key;\n    if (isPremovable(state, key)) {\n        // calculate chess premoves if custom premoves are not passed\n        if (!state.premovable.customDests) {\n            state.premovable.dests = (0,_premove_js__WEBPACK_IMPORTED_MODULE_1__.premove)(state.pieces, key, state.premovable.castle);\n        }\n    }\n    else\n        state.premovable.dests = undefined;\n}\nfunction unselect(state) {\n    state.selected = undefined;\n    state.premovable.dests = undefined;\n    state.hold.cancel();\n}\nfunction isMovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        (state.movable.color === 'both' || (state.movable.color === piece.color && state.turnColor === piece.color)));\n}\nconst canMove = (state, orig, dest) => { var _a, _b; return orig !== dest && isMovable(state, orig) && (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest))); };\nfunction canDrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        (orig === dest || !state.pieces.has(dest)) &&\n        (state.movable.color === 'both' || (state.movable.color === piece.color && state.turnColor === piece.color)));\n}\nfunction isPremovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nfunction canPremove(state, orig, dest) {\n    var _a, _b;\n    const validPremoves = (_b = (_a = state.premovable.customDests) === null || _a === void 0 ? void 0 : _a.get(orig)) !== null && _b !== void 0 ? _b : (0,_premove_js__WEBPACK_IMPORTED_MODULE_1__.premove)(state.pieces, orig, state.premovable.castle);\n    return orig !== dest && isPremovable(state, orig) && validPremoves.includes(dest);\n}\nfunction canPredrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    const destPiece = state.pieces.get(dest);\n    return (!!piece &&\n        (!destPiece || destPiece.color !== state.movable.color) &&\n        state.predroppable.enabled &&\n        (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&\n        state.movable.color === piece.color &&\n        state.turnColor !== piece.color);\n}\nfunction isDraggable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        state.draggable.enabled &&\n        (state.movable.color === 'both' ||\n            (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled))));\n}\nfunction playPremove(state) {\n    const move = state.premovable.current;\n    if (!move)\n        return false;\n    const orig = move[0], dest = move[1];\n    let success = false;\n    if (canMove(state, orig, dest)) {\n        const result = baseUserMove(state, orig, dest);\n        if (result) {\n            const metadata = { premove: true };\n            if (result !== true)\n                metadata.captured = result;\n            callUserFunction(state.movable.events.after, orig, dest, metadata);\n            success = true;\n        }\n    }\n    unsetPremove(state);\n    return success;\n}\nfunction playPredrop(state, validate) {\n    const drop = state.predroppable.current;\n    let success = false;\n    if (!drop)\n        return false;\n    if (validate(drop)) {\n        const piece = {\n            role: drop.role,\n            color: state.movable.color,\n        };\n        if (baseNewPiece(state, piece, drop.key)) {\n            callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n                premove: false,\n                predrop: true,\n            });\n            success = true;\n        }\n    }\n    unsetPredrop(state);\n    return success;\n}\nfunction cancelMove(state) {\n    unsetPremove(state);\n    unsetPredrop(state);\n    unselect(state);\n}\nfunction stop(state) {\n    state.movable.color = state.movable.dests = state.animation.current = undefined;\n    cancelMove(state);\n}\nfunction getKeyAtDomPos(pos, asWhite, bounds) {\n    let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);\n    if (!asWhite)\n        file = 7 - file;\n    let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);\n    if (!asWhite)\n        rank = 7 - rank;\n    return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([file, rank]) : undefined;\n}\nfunction getSnappedKeyAtDomPos(orig, pos, asWhite, bounds) {\n    const origPos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(orig);\n    const validSnapPos = _util_js__WEBPACK_IMPORTED_MODULE_0__.allPos.filter(pos2 => (0,_premove_js__WEBPACK_IMPORTED_MODULE_1__.queen)(origPos[0], origPos[1], pos2[0], pos2[1]) || (0,_premove_js__WEBPACK_IMPORTED_MODULE_1__.knight)(origPos[0], origPos[1], pos2[0], pos2[1]));\n    const validSnapCenters = validSnapPos.map(pos2 => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.computeSquareCenter)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)(pos2), asWhite, bounds));\n    const validSnapDistances = validSnapCenters.map(pos2 => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.distanceSq)(pos, pos2));\n    const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index) => (a[0] < b ? a : [b, index]), [validSnapDistances[0], 0]);\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)(validSnapPos[closestSnapIndex]);\n}\nconst whitePov = (s) => s.orientation === 'white';\n//# sourceMappingURL=board.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/board.js?");

/***/ }),

/***/ "./node_modules/chessground/chessground.js":
/*!*************************************************!*\
  !*** ./node_modules/chessground/chessground.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chessground: () => (/* binding */ Chessground)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"./node_modules/chessground/api.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"./node_modules/chessground/config.js\");\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./state.js */ \"./node_modules/chessground/state.js\");\n/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrap.js */ \"./node_modules/chessground/wrap.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ \"./node_modules/chessground/events.js\");\n/* harmony import */ var _render_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./render.js */ \"./node_modules/chessground/render.js\");\n/* harmony import */ var _autoPieces_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./autoPieces.js */ \"./node_modules/chessground/autoPieces.js\");\n/* harmony import */ var _svg_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./svg.js */ \"./node_modules/chessground/svg.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n\n\n\n\n\n\n\n\n\nfunction Chessground(element, config) {\n    const maybeState = (0,_state_js__WEBPACK_IMPORTED_MODULE_2__.defaults)();\n    (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.configure)(maybeState, config || {});\n    function redrawAll() {\n        const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n        // compute bounds from existing board element if possible\n        // this allows non-square boards from CSS to be handled (for 3D)\n        const elements = (0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.renderWrap)(element, maybeState), bounds = _util_js__WEBPACK_IMPORTED_MODULE_8__.memo(() => elements.board.getBoundingClientRect()), redrawNow = (skipSvg) => {\n            (0,_render_js__WEBPACK_IMPORTED_MODULE_5__.render)(state);\n            if (elements.autoPieces)\n                _autoPieces_js__WEBPACK_IMPORTED_MODULE_6__.render(state, elements.autoPieces);\n            if (!skipSvg && elements.svg)\n                _svg_js__WEBPACK_IMPORTED_MODULE_7__.renderSvg(state, elements.svg, elements.customSvg);\n        }, onResize = () => {\n            (0,_render_js__WEBPACK_IMPORTED_MODULE_5__.updateBounds)(state);\n            (0,_render_js__WEBPACK_IMPORTED_MODULE_5__.renderResized)(state);\n            if (elements.autoPieces)\n                _autoPieces_js__WEBPACK_IMPORTED_MODULE_6__.renderResized(state);\n        };\n        const state = maybeState;\n        state.dom = {\n            elements,\n            bounds,\n            redraw: debounceRedraw(redrawNow),\n            redrawNow,\n            unbind: prevUnbind,\n        };\n        state.drawable.prevSvgHash = '';\n        (0,_render_js__WEBPACK_IMPORTED_MODULE_5__.updateBounds)(state);\n        redrawNow(false);\n        _events_js__WEBPACK_IMPORTED_MODULE_4__.bindBoard(state, onResize);\n        if (!prevUnbind)\n            state.dom.unbind = _events_js__WEBPACK_IMPORTED_MODULE_4__.bindDocument(state, onResize);\n        state.events.insert && state.events.insert(elements);\n        return state;\n    }\n    return (0,_api_js__WEBPACK_IMPORTED_MODULE_0__.start)(redrawAll(), redrawAll);\n}\nfunction debounceRedraw(redrawNow) {\n    let redrawing = false;\n    return () => {\n        if (redrawing)\n            return;\n        redrawing = true;\n        requestAnimationFrame(() => {\n            redrawNow();\n            redrawing = false;\n        });\n    };\n}\n//# sourceMappingURL=chessground.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/chessground.js?");

/***/ }),

/***/ "./node_modules/chessground/config.js":
/*!********************************************!*\
  !*** ./node_modules/chessground/config.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAnimation: () => (/* binding */ applyAnimation),\n/* harmony export */   configure: () => (/* binding */ configure)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/chessground/board.js\");\n/* harmony import */ var _fen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fen.js */ \"./node_modules/chessground/fen.js\");\n\n\nfunction applyAnimation(state, config) {\n    if (config.animation) {\n        deepMerge(state.animation, config.animation);\n        // no need for such short animations\n        if ((state.animation.duration || 0) < 70)\n            state.animation.enabled = false;\n    }\n}\nfunction configure(state, config) {\n    var _a, _b, _c;\n    // don't merge destinations and autoShapes. Just override.\n    if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests)\n        state.movable.dests = undefined;\n    if ((_b = config.drawable) === null || _b === void 0 ? void 0 : _b.autoShapes)\n        state.drawable.autoShapes = [];\n    deepMerge(state, config);\n    // if a fen was provided, replace the pieces\n    if (config.fen) {\n        state.pieces = (0,_fen_js__WEBPACK_IMPORTED_MODULE_1__.read)(config.fen);\n        state.drawable.shapes = ((_c = config.drawable) === null || _c === void 0 ? void 0 : _c.shapes) || [];\n    }\n    // apply config values that could be undefined yet meaningful\n    if ('check' in config)\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.setCheck)(state, config.check || false);\n    if ('lastMove' in config && !config.lastMove)\n        state.lastMove = undefined;\n    // in case of ZH drop last move, there's a single square.\n    // if the previous last move had two squares,\n    // the merge algorithm will incorrectly keep the second square.\n    else if (config.lastMove)\n        state.lastMove = config.lastMove;\n    // fix move/premove dests\n    if (state.selected)\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.setSelected)(state, state.selected);\n    applyAnimation(state, config);\n    if (!state.movable.rookCastle && state.movable.dests) {\n        const rank = state.movable.color === 'white' ? '1' : '8', kingStartPos = ('e' + rank), dests = state.movable.dests.get(kingStartPos), king = state.pieces.get(kingStartPos);\n        if (!dests || !king || king.role !== 'king')\n            return;\n        state.movable.dests.set(kingStartPos, dests.filter(d => !(d === 'a' + rank && dests.includes(('c' + rank))) &&\n            !(d === 'h' + rank && dests.includes(('g' + rank)))));\n    }\n}\nfunction deepMerge(base, extend) {\n    for (const key in extend) {\n        if (Object.prototype.hasOwnProperty.call(extend, key)) {\n            if (Object.prototype.hasOwnProperty.call(base, key) && isPlainObject(base[key]) && isPlainObject(extend[key]))\n                deepMerge(base[key], extend[key]);\n            else\n                base[key] = extend[key];\n        }\n    }\n}\nfunction isPlainObject(o) {\n    if (typeof o !== 'object' || o === null)\n        return false;\n    const proto = Object.getPrototypeOf(o);\n    return proto === Object.prototype || proto === null;\n}\n//# sourceMappingURL=config.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/config.js?");

/***/ }),

/***/ "./node_modules/chessground/drag.js":
/*!******************************************!*\
  !*** ./node_modules/chessground/drag.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancel: () => (/* binding */ cancel),\n/* harmony export */   dragNewPiece: () => (/* binding */ dragNewPiece),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   start: () => (/* binding */ start)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/chessground/board.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n/* harmony import */ var _draw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./draw.js */ \"./node_modules/chessground/draw.js\");\n/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anim.js */ \"./node_modules/chessground/anim.js\");\n\n\n\n\nfunction start(s, e) {\n    if (!(s.trustAllEvents || e.isTrusted))\n        return; // only trust when trustAllEvents is enabled\n    if (e.button !== undefined && e.button !== 0)\n        return; // only touch or left click\n    if (e.touches && e.touches.length > 1)\n        return; // support one finger touch only\n    const bounds = s.dom.bounds(), position = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e), orig = _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(position, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), bounds);\n    if (!orig)\n        return;\n    const piece = s.pieces.get(orig);\n    const previouslySelected = s.selected;\n    if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor))\n        (0,_draw_js__WEBPACK_IMPORTED_MODULE_2__.clear)(s);\n    // Prevent touch scroll and create no corresponding mouse event, if there\n    // is an intent to interact with the board.\n    if (e.cancelable !== false &&\n        (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position)))\n        e.preventDefault();\n    else if (e.touches)\n        return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n    const hadPremove = !!s.premovable.current;\n    const hadPredrop = !!s.predroppable.current;\n    s.stats.ctrlKey = e.ctrlKey;\n    if (s.selected && _board_js__WEBPACK_IMPORTED_MODULE_0__.canMove(s, s.selected, orig)) {\n        (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.selectSquare(state, orig), s);\n    }\n    else {\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.selectSquare(s, orig);\n    }\n    const stillSelected = s.selected === orig;\n    const element = pieceElementByKey(s, orig);\n    if (piece && element && stillSelected && _board_js__WEBPACK_IMPORTED_MODULE_0__.isDraggable(s, orig)) {\n        s.draggable.current = {\n            orig,\n            piece,\n            origPos: position,\n            pos: position,\n            started: s.draggable.autoDistance && s.stats.dragged,\n            element,\n            previouslySelected,\n            originTarget: e.target,\n            keyHasChanged: false,\n        };\n        element.cgDragging = true;\n        element.classList.add('dragging');\n        // place ghost\n        const ghost = s.dom.elements.ghost;\n        if (ghost) {\n            ghost.className = `ghost ${piece.color} ${piece.role}`;\n            _util_js__WEBPACK_IMPORTED_MODULE_1__.translate(ghost, _util_js__WEBPACK_IMPORTED_MODULE_1__.posToTranslate(bounds)(_util_js__WEBPACK_IMPORTED_MODULE_1__.key2pos(orig), _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s)));\n            _util_js__WEBPACK_IMPORTED_MODULE_1__.setVisible(ghost, true);\n        }\n        processDrag(s);\n    }\n    else {\n        if (hadPremove)\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPremove(s);\n        if (hadPredrop)\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPredrop(s);\n    }\n    s.dom.redraw();\n}\nfunction pieceCloseTo(s, pos) {\n    const asWhite = _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);\n    for (const key of s.pieces.keys()) {\n        const center = _util_js__WEBPACK_IMPORTED_MODULE_1__.computeSquareCenter(key, asWhite, bounds);\n        if (_util_js__WEBPACK_IMPORTED_MODULE_1__.distanceSq(center, pos) <= radiusSq)\n            return true;\n    }\n    return false;\n}\nfunction dragNewPiece(s, piece, e, force) {\n    const key = 'a0';\n    s.pieces.set(key, piece);\n    s.dom.redraw();\n    const position = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e);\n    s.draggable.current = {\n        orig: key,\n        piece,\n        origPos: position,\n        pos: position,\n        started: true,\n        element: () => pieceElementByKey(s, key),\n        originTarget: e.target,\n        newPiece: true,\n        force: !!force,\n        keyHasChanged: false,\n    };\n    processDrag(s);\n}\nfunction processDrag(s) {\n    requestAnimationFrame(() => {\n        var _a;\n        const cur = s.draggable.current;\n        if (!cur)\n            return;\n        // cancel animations while dragging\n        if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig))\n            s.animation.current = undefined;\n        // if moving piece is gone, cancel\n        const origPiece = s.pieces.get(cur.orig);\n        if (!origPiece || !_util_js__WEBPACK_IMPORTED_MODULE_1__.samePiece(origPiece, cur.piece))\n            cancel(s);\n        else {\n            if (!cur.started && _util_js__WEBPACK_IMPORTED_MODULE_1__.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n                cur.started = true;\n            if (cur.started) {\n                // support lazy elements\n                if (typeof cur.element === 'function') {\n                    const found = cur.element();\n                    if (!found)\n                        return;\n                    found.cgDragging = true;\n                    found.classList.add('dragging');\n                    cur.element = found;\n                }\n                const bounds = s.dom.bounds();\n                _util_js__WEBPACK_IMPORTED_MODULE_1__.translate(cur.element, [\n                    cur.pos[0] - bounds.left - bounds.width / 16,\n                    cur.pos[1] - bounds.top - bounds.height / 16,\n                ]);\n                cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(cur.pos, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), bounds));\n            }\n        }\n        processDrag(s);\n    });\n}\nfunction move(s, e) {\n    // support one finger touch only\n    if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n        s.draggable.current.pos = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e);\n    }\n}\nfunction end(s, e) {\n    const cur = s.draggable.current;\n    if (!cur)\n        return;\n    // create no corresponding mouse event\n    if (e.type === 'touchend' && e.cancelable !== false)\n        e.preventDefault();\n    // comparing with the origin target is an easy way to test that the end event\n    // has the same touch origin\n    if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n        s.draggable.current = undefined;\n        return;\n    }\n    _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPremove(s);\n    _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPredrop(s);\n    // touchend has no position; so use the last touchmove position instead\n    const eventPos = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e) || cur.pos;\n    const dest = _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(eventPos, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), s.dom.bounds());\n    if (dest && cur.started && cur.orig !== dest) {\n        if (cur.newPiece)\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.dropNewPiece(s, cur.orig, dest, cur.force);\n        else {\n            s.stats.ctrlKey = e.ctrlKey;\n            if (_board_js__WEBPACK_IMPORTED_MODULE_0__.userMove(s, cur.orig, dest))\n                s.stats.dragged = true;\n        }\n    }\n    else if (cur.newPiece) {\n        s.pieces.delete(cur.orig);\n    }\n    else if (s.draggable.deleteOnDropOff && !dest) {\n        s.pieces.delete(cur.orig);\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.callUserFunction(s.events.change);\n    }\n    if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.unselect(s);\n    else if (!s.selectable.enabled)\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.unselect(s);\n    removeDragElements(s);\n    s.draggable.current = undefined;\n    s.dom.redraw();\n}\nfunction cancel(s) {\n    const cur = s.draggable.current;\n    if (cur) {\n        if (cur.newPiece)\n            s.pieces.delete(cur.orig);\n        s.draggable.current = undefined;\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.unselect(s);\n        removeDragElements(s);\n        s.dom.redraw();\n    }\n}\nfunction removeDragElements(s) {\n    const e = s.dom.elements;\n    if (e.ghost)\n        _util_js__WEBPACK_IMPORTED_MODULE_1__.setVisible(e.ghost, false);\n}\nfunction pieceElementByKey(s, key) {\n    let el = s.dom.elements.board.firstChild;\n    while (el) {\n        if (el.cgKey === key && el.tagName === 'PIECE')\n            return el;\n        el = el.nextSibling;\n    }\n    return;\n}\n//# sourceMappingURL=drag.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/drag.js?");

/***/ }),

/***/ "./node_modules/chessground/draw.js":
/*!******************************************!*\
  !*** ./node_modules/chessground/draw.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancel: () => (/* binding */ cancel),\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   processDraw: () => (/* binding */ processDraw),\n/* harmony export */   start: () => (/* binding */ start)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/chessground/board.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n\n\nconst brushes = ['green', 'red', 'blue', 'yellow'];\nfunction start(state, e) {\n    // support one finger touch only\n    if (e.touches && e.touches.length > 1)\n        return;\n    e.stopPropagation();\n    e.preventDefault();\n    e.ctrlKey ? (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.unselect)(state) : (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.cancelMove)(state);\n    const pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition)(e), orig = (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos)(pos, (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov)(state), state.dom.bounds());\n    if (!orig)\n        return;\n    state.drawable.current = {\n        orig,\n        pos,\n        brush: eventBrush(e),\n        snapToValidMove: state.drawable.defaultSnapToValidMove,\n    };\n    processDraw(state);\n}\nfunction processDraw(state) {\n    requestAnimationFrame(() => {\n        const cur = state.drawable.current;\n        if (cur) {\n            const keyAtDomPos = (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos)(cur.pos, (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov)(state), state.dom.bounds());\n            if (!keyAtDomPos) {\n                cur.snapToValidMove = false;\n            }\n            const mouseSq = cur.snapToValidMove\n                ? (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.getSnappedKeyAtDomPos)(cur.orig, cur.pos, (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov)(state), state.dom.bounds())\n                : keyAtDomPos;\n            if (mouseSq !== cur.mouseSq) {\n                cur.mouseSq = mouseSq;\n                cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n                state.dom.redrawNow();\n            }\n            processDraw(state);\n        }\n    });\n}\nfunction move(state, e) {\n    if (state.drawable.current)\n        state.drawable.current.pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition)(e);\n}\nfunction end(state) {\n    const cur = state.drawable.current;\n    if (cur) {\n        if (cur.mouseSq)\n            addShape(state.drawable, cur);\n        cancel(state);\n    }\n}\nfunction cancel(state) {\n    if (state.drawable.current) {\n        state.drawable.current = undefined;\n        state.dom.redraw();\n    }\n}\nfunction clear(state) {\n    if (state.drawable.shapes.length) {\n        state.drawable.shapes = [];\n        state.dom.redraw();\n        onChange(state.drawable);\n    }\n}\nfunction eventBrush(e) {\n    var _a;\n    const modA = (e.shiftKey || e.ctrlKey) && (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isRightButton)(e);\n    const modB = e.altKey || e.metaKey || ((_a = e.getModifierState) === null || _a === void 0 ? void 0 : _a.call(e, 'AltGraph'));\n    return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\nfunction addShape(drawable, cur) {\n    const sameShape = (s) => s.orig === cur.orig && s.dest === cur.dest;\n    const similar = drawable.shapes.find(sameShape);\n    if (similar)\n        drawable.shapes = drawable.shapes.filter(s => !sameShape(s));\n    if (!similar || similar.brush !== cur.brush)\n        drawable.shapes.push({\n            orig: cur.orig,\n            dest: cur.dest,\n            brush: cur.brush,\n        });\n    onChange(drawable);\n}\nfunction onChange(drawable) {\n    if (drawable.onChange)\n        drawable.onChange(drawable.shapes);\n}\n//# sourceMappingURL=draw.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/draw.js?");

/***/ }),

/***/ "./node_modules/chessground/drop.js":
/*!******************************************!*\
  !*** ./node_modules/chessground/drop.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancelDropMode: () => (/* binding */ cancelDropMode),\n/* harmony export */   drop: () => (/* binding */ drop),\n/* harmony export */   setDropMode: () => (/* binding */ setDropMode)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/chessground/board.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drag.js */ \"./node_modules/chessground/drag.js\");\n\n\n\nfunction setDropMode(s, piece) {\n    s.dropmode = {\n        active: true,\n        piece,\n    };\n    (0,_drag_js__WEBPACK_IMPORTED_MODULE_2__.cancel)(s);\n}\nfunction cancelDropMode(s) {\n    s.dropmode = {\n        active: false,\n    };\n}\nfunction drop(s, e) {\n    if (!s.dropmode.active)\n        return;\n    _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPremove(s);\n    _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPredrop(s);\n    const piece = s.dropmode.piece;\n    if (piece) {\n        s.pieces.set('a0', piece);\n        const position = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e);\n        const dest = position && _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(position, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), s.dom.bounds());\n        if (dest)\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.dropNewPiece(s, 'a0', dest);\n    }\n    s.dom.redraw();\n}\n//# sourceMappingURL=drop.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/drop.js?");

/***/ }),

/***/ "./node_modules/chessground/events.js":
/*!********************************************!*\
  !*** ./node_modules/chessground/events.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bindBoard: () => (/* binding */ bindBoard),\n/* harmony export */   bindDocument: () => (/* binding */ bindDocument)\n/* harmony export */ });\n/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag.js */ \"./node_modules/chessground/drag.js\");\n/* harmony import */ var _draw_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw.js */ \"./node_modules/chessground/draw.js\");\n/* harmony import */ var _drop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drop.js */ \"./node_modules/chessground/drop.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n\n\n\n\nfunction bindBoard(s, onResize) {\n    const boardEl = s.dom.elements.board;\n    if ('ResizeObserver' in window)\n        new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n    if (s.disableContextMenu || s.drawable.enabled) {\n        boardEl.addEventListener('contextmenu', e => e.preventDefault());\n    }\n    if (s.viewOnly)\n        return;\n    // Cannot be passive, because we prevent touch scrolling and dragging of\n    // selected elements.\n    const onStart = startDragOrDraw(s);\n    boardEl.addEventListener('touchstart', onStart, {\n        passive: false,\n    });\n    boardEl.addEventListener('mousedown', onStart, {\n        passive: false,\n    });\n}\n// returns the unbind function\nfunction bindDocument(s, onResize) {\n    const unbinds = [];\n    // Old versions of Edge and Safari do not support ResizeObserver. Send\n    // chessground.resize if a user action has changed the bounds of the board.\n    if (!('ResizeObserver' in window))\n        unbinds.push(unbindable(document.body, 'chessground.resize', onResize));\n    if (!s.viewOnly) {\n        const onmove = dragOrDraw(s, _drag_js__WEBPACK_IMPORTED_MODULE_0__.move, _draw_js__WEBPACK_IMPORTED_MODULE_1__.move);\n        const onend = dragOrDraw(s, _drag_js__WEBPACK_IMPORTED_MODULE_0__.end, _draw_js__WEBPACK_IMPORTED_MODULE_1__.end);\n        for (const ev of ['touchmove', 'mousemove'])\n            unbinds.push(unbindable(document, ev, onmove));\n        for (const ev of ['touchend', 'mouseup'])\n            unbinds.push(unbindable(document, ev, onend));\n        const onScroll = () => s.dom.bounds.clear();\n        unbinds.push(unbindable(document, 'scroll', onScroll, { capture: true, passive: true }));\n        unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));\n    }\n    return () => unbinds.forEach(f => f());\n}\nfunction unbindable(el, eventName, callback, options) {\n    el.addEventListener(eventName, callback, options);\n    return () => el.removeEventListener(eventName, callback, options);\n}\nconst startDragOrDraw = (s) => e => {\n    if (s.draggable.current)\n        _drag_js__WEBPACK_IMPORTED_MODULE_0__.cancel(s);\n    else if (s.drawable.current)\n        _draw_js__WEBPACK_IMPORTED_MODULE_1__.cancel(s);\n    else if (e.shiftKey || (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.isRightButton)(e)) {\n        if (s.drawable.enabled)\n            _draw_js__WEBPACK_IMPORTED_MODULE_1__.start(s, e);\n    }\n    else if (!s.viewOnly) {\n        if (s.dropmode.active)\n            (0,_drop_js__WEBPACK_IMPORTED_MODULE_2__.drop)(s, e);\n        else\n            _drag_js__WEBPACK_IMPORTED_MODULE_0__.start(s, e);\n    }\n};\nconst dragOrDraw = (s, withDrag, withDraw) => e => {\n    if (s.drawable.current) {\n        if (s.drawable.enabled)\n            withDraw(s, e);\n    }\n    else if (!s.viewOnly)\n        withDrag(s, e);\n};\n//# sourceMappingURL=events.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/events.js?");

/***/ }),

/***/ "./node_modules/chessground/explosion.js":
/*!***********************************************!*\
  !*** ./node_modules/chessground/explosion.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   explosion: () => (/* binding */ explosion)\n/* harmony export */ });\nfunction explosion(state, keys) {\n    state.exploding = { stage: 1, keys };\n    state.dom.redraw();\n    setTimeout(() => {\n        setStage(state, 2);\n        setTimeout(() => setStage(state, undefined), 120);\n    }, 120);\n}\nfunction setStage(state, stage) {\n    if (state.exploding) {\n        if (stage)\n            state.exploding.stage = stage;\n        else\n            state.exploding = undefined;\n        state.dom.redraw();\n    }\n}\n//# sourceMappingURL=explosion.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/explosion.js?");

/***/ }),

/***/ "./node_modules/chessground/fen.js":
/*!*****************************************!*\
  !*** ./node_modules/chessground/fen.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initial: () => (/* binding */ initial),\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   write: () => (/* binding */ write)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"./node_modules/chessground/types.js\");\n\n\nconst initial = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nconst roles = {\n    p: 'pawn',\n    r: 'rook',\n    n: 'knight',\n    b: 'bishop',\n    q: 'queen',\n    k: 'king',\n};\nconst letters = {\n    pawn: 'p',\n    rook: 'r',\n    knight: 'n',\n    bishop: 'b',\n    queen: 'q',\n    king: 'k',\n};\nfunction read(fen) {\n    if (fen === 'start')\n        fen = initial;\n    const pieces = new Map();\n    let row = 7, col = 0;\n    for (const c of fen) {\n        switch (c) {\n            case ' ':\n            case '[':\n                return pieces;\n            case '/':\n                --row;\n                if (row < 0)\n                    return pieces;\n                col = 0;\n                break;\n            case '~': {\n                const piece = pieces.get((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([col - 1, row]));\n                if (piece)\n                    piece.promoted = true;\n                break;\n            }\n            default: {\n                const nb = c.charCodeAt(0);\n                if (nb < 57)\n                    col += nb - 48;\n                else {\n                    const role = c.toLowerCase();\n                    pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([col, row]), {\n                        role: roles[role],\n                        color: c === role ? 'black' : 'white',\n                    });\n                    ++col;\n                }\n            }\n        }\n    }\n    return pieces;\n}\nfunction write(pieces) {\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.invRanks\n        .map(y => _types_js__WEBPACK_IMPORTED_MODULE_1__.files\n        .map(x => {\n        const piece = pieces.get((x + y));\n        if (piece) {\n            let p = letters[piece.role];\n            if (piece.color === 'white')\n                p = p.toUpperCase();\n            if (piece.promoted)\n                p += '~';\n            return p;\n        }\n        else\n            return '1';\n    })\n        .join(''))\n        .join('/')\n        .replace(/1{2,}/g, s => s.length.toString());\n}\n//# sourceMappingURL=fen.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/fen.js?");

/***/ }),

/***/ "./node_modules/chessground/premove.js":
/*!*********************************************!*\
  !*** ./node_modules/chessground/premove.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   knight: () => (/* binding */ knight),\n/* harmony export */   premove: () => (/* binding */ premove),\n/* harmony export */   queen: () => (/* binding */ queen)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n\nconst diff = (a, b) => Math.abs(a - b);\nconst pawn = (color) => (x1, y1, x2, y2) => diff(x1, x2) < 2 &&\n    (color === 'white'\n        ? // allow 2 squares from first two ranks, for horde\n            y2 === y1 + 1 || (y1 <= 1 && y2 === y1 + 2 && x1 === x2)\n        : y2 === y1 - 1 || (y1 >= 6 && y2 === y1 - 2 && x1 === x2));\nconst knight = (x1, y1, x2, y2) => {\n    const xd = diff(x1, x2);\n    const yd = diff(y1, y2);\n    return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);\n};\nconst bishop = (x1, y1, x2, y2) => {\n    return diff(x1, x2) === diff(y1, y2);\n};\nconst rook = (x1, y1, x2, y2) => {\n    return x1 === x2 || y1 === y2;\n};\nconst queen = (x1, y1, x2, y2) => {\n    return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);\n};\nconst king = (color, rookFiles, canCastle) => (x1, y1, x2, y2) => (diff(x1, x2) < 2 && diff(y1, y2) < 2) ||\n    (canCastle &&\n        y1 === y2 &&\n        y1 === (color === 'white' ? 0 : 7) &&\n        ((x1 === 4 && ((x2 === 2 && rookFiles.includes(0)) || (x2 === 6 && rookFiles.includes(7)))) ||\n            rookFiles.includes(x2)));\nfunction rookFilesOf(pieces, color) {\n    const backrank = color === 'white' ? '1' : '8';\n    const files = [];\n    for (const [key, piece] of pieces) {\n        if (key[1] === backrank && piece.color === color && piece.role === 'rook') {\n            files.push(_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos(key)[0]);\n        }\n    }\n    return files;\n}\nfunction premove(pieces, key, canCastle) {\n    const piece = pieces.get(key);\n    if (!piece)\n        return [];\n    const pos = _util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos(key), r = piece.role, mobility = r === 'pawn'\n        ? pawn(piece.color)\n        : r === 'knight'\n            ? knight\n            : r === 'bishop'\n                ? bishop\n                : r === 'rook'\n                    ? rook\n                    : r === 'queen'\n                        ? queen\n                        : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.allPos\n        .filter(pos2 => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]))\n        .map(_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key);\n}\n//# sourceMappingURL=premove.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/premove.js?");

/***/ }),

/***/ "./node_modules/chessground/render.js":
/*!********************************************!*\
  !*** ./node_modules/chessground/render.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   renderResized: () => (/* binding */ renderResized),\n/* harmony export */   updateBounds: () => (/* binding */ updateBounds)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./node_modules/chessground/board.js\");\n\n\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nfunction render(s) {\n    const asWhite = (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.whitePov)(s), posToTranslate = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.posToTranslate)(s.dom.bounds()), boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : new Map(), fadings = curAnim ? curAnim.plan.fadings : new Map(), curDrag = s.draggable.current, squares = computeSquareClasses(s), samePieces = new Set(), sameSquares = new Set(), movedPieces = new Map(), movedSquares = new Map(); // by class name\n    let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;\n    // walk over all board dom elements, apply animations and flag moved pieces\n    el = boardEl.firstChild;\n    while (el) {\n        k = el.cgKey;\n        if (isPieceNode(el)) {\n            pieceAtKey = pieces.get(k);\n            anim = anims.get(k);\n            fading = fadings.get(k);\n            elPieceName = el.cgPiece;\n            // if piece not being dragged anymore, remove dragging style\n            if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n                el.classList.remove('dragging');\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(el, posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k), asWhite));\n                el.cgDragging = false;\n            }\n            // remove fading class if it still remains\n            if (!fading && el.cgFading) {\n                el.cgFading = false;\n                el.classList.remove('fading');\n            }\n            // there is now a piece at this dom key\n            if (pieceAtKey) {\n                // continue animation if already animating and same piece\n                // (otherwise it could animate a captured piece)\n                if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n                    const pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k);\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                    el.classList.add('anim');\n                    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(el, posToTranslate(pos, asWhite));\n                }\n                else if (el.cgAnimating) {\n                    el.cgAnimating = false;\n                    el.classList.remove('anim');\n                    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(el, posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k), asWhite));\n                    if (s.addPieceZIndex)\n                        el.style.zIndex = posZIndex((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k), asWhite);\n                }\n                // same piece: flag as same\n                if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n                    samePieces.add(k);\n                }\n                // different piece: flag as moved unless it is a fading piece\n                else {\n                    if (fading && elPieceName === pieceNameOf(fading)) {\n                        el.classList.add('fading');\n                        el.cgFading = true;\n                    }\n                    else {\n                        appendValue(movedPieces, elPieceName, el);\n                    }\n                }\n            }\n            // no piece: flag as moved\n            else {\n                appendValue(movedPieces, elPieceName, el);\n            }\n        }\n        else if (isSquareNode(el)) {\n            const cn = el.className;\n            if (squares.get(k) === cn)\n                sameSquares.add(k);\n            else\n                appendValue(movedSquares, cn, el);\n        }\n        el = el.nextSibling;\n    }\n    // walk over all squares in current set, apply dom changes to moved squares\n    // or append new squares\n    for (const [sk, className] of squares) {\n        if (!sameSquares.has(sk)) {\n            sMvdset = movedSquares.get(className);\n            sMvd = sMvdset && sMvdset.pop();\n            const translation = posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(sk), asWhite);\n            if (sMvd) {\n                sMvd.cgKey = sk;\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(sMvd, translation);\n            }\n            else {\n                const squareNode = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('square', className);\n                squareNode.cgKey = sk;\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(squareNode, translation);\n                boardEl.insertBefore(squareNode, boardEl.firstChild);\n            }\n        }\n    }\n    // walk over all pieces in current set, apply dom changes to moved pieces\n    // or append new pieces\n    for (const [k, p] of pieces) {\n        anim = anims.get(k);\n        if (!samePieces.has(k)) {\n            pMvdset = movedPieces.get(pieceNameOf(p));\n            pMvd = pMvdset && pMvdset.pop();\n            // a same piece was moved\n            if (pMvd) {\n                // apply dom changes\n                pMvd.cgKey = k;\n                if (pMvd.cgFading) {\n                    pMvd.classList.remove('fading');\n                    pMvd.cgFading = false;\n                }\n                const pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k);\n                if (s.addPieceZIndex)\n                    pMvd.style.zIndex = posZIndex(pos, asWhite);\n                if (anim) {\n                    pMvd.cgAnimating = true;\n                    pMvd.classList.add('anim');\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(pMvd, posToTranslate(pos, asWhite));\n            }\n            // no piece in moved obj: insert the new piece\n            // assumes the new piece is not being dragged\n            else {\n                const pieceName = pieceNameOf(p), pieceNode = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('piece', pieceName), pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k);\n                pieceNode.cgPiece = pieceName;\n                pieceNode.cgKey = k;\n                if (anim) {\n                    pieceNode.cgAnimating = true;\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(pieceNode, posToTranslate(pos, asWhite));\n                if (s.addPieceZIndex)\n                    pieceNode.style.zIndex = posZIndex(pos, asWhite);\n                boardEl.appendChild(pieceNode);\n            }\n        }\n    }\n    // remove any element that remains in the moved sets\n    for (const nodes of movedPieces.values())\n        removeNodes(s, nodes);\n    for (const nodes of movedSquares.values())\n        removeNodes(s, nodes);\n}\nfunction renderResized(s) {\n    const asWhite = (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.whitePov)(s), posToTranslate = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.posToTranslate)(s.dom.bounds());\n    let el = s.dom.elements.board.firstChild;\n    while (el) {\n        if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(el, posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(el.cgKey), asWhite));\n        }\n        el = el.nextSibling;\n    }\n}\nfunction updateBounds(s) {\n    var _a, _b;\n    const bounds = s.dom.elements.wrap.getBoundingClientRect();\n    const container = s.dom.elements.container;\n    const ratio = bounds.height / bounds.width;\n    const width = (Math.floor((bounds.width * window.devicePixelRatio) / 8) * 8) / window.devicePixelRatio;\n    const height = width * ratio;\n    container.style.width = width + 'px';\n    container.style.height = height + 'px';\n    s.dom.bounds.clear();\n    (_a = s.addDimensionsCssVarsTo) === null || _a === void 0 ? void 0 : _a.style.setProperty('--cg-width', width + 'px');\n    (_b = s.addDimensionsCssVarsTo) === null || _b === void 0 ? void 0 : _b.style.setProperty('--cg-height', height + 'px');\n}\nconst isPieceNode = (el) => el.tagName === 'PIECE';\nconst isSquareNode = (el) => el.tagName === 'SQUARE';\nfunction removeNodes(s, nodes) {\n    for (const node of nodes)\n        s.dom.elements.board.removeChild(node);\n}\nfunction posZIndex(pos, asWhite) {\n    const minZ = 3;\n    const rank = pos[1];\n    const z = asWhite ? minZ + 7 - rank : minZ + rank;\n    return `${z}`;\n}\nconst pieceNameOf = (piece) => `${piece.color} ${piece.role}`;\nfunction computeSquareClasses(s) {\n    var _a, _b, _c;\n    const squares = new Map();\n    if (s.lastMove && s.highlight.lastMove)\n        for (const k of s.lastMove) {\n            addSquare(squares, k, 'last-move');\n        }\n    if (s.check && s.highlight.check)\n        addSquare(squares, s.check, 'check');\n    if (s.selected) {\n        addSquare(squares, s.selected, 'selected');\n        if (s.movable.showDests) {\n            const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);\n            if (dests)\n                for (const k of dests) {\n                    addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n                }\n            const pDests = (_c = (_b = s.premovable.customDests) === null || _b === void 0 ? void 0 : _b.get(s.selected)) !== null && _c !== void 0 ? _c : s.premovable.dests;\n            if (pDests)\n                for (const k of pDests) {\n                    addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n                }\n        }\n    }\n    const premove = s.premovable.current;\n    if (premove)\n        for (const k of premove)\n            addSquare(squares, k, 'current-premove');\n    else if (s.predroppable.current)\n        addSquare(squares, s.predroppable.current.key, 'current-premove');\n    const o = s.exploding;\n    if (o)\n        for (const k of o.keys)\n            addSquare(squares, k, 'exploding' + o.stage);\n    if (s.highlight.custom) {\n        s.highlight.custom.forEach((v, k) => {\n            addSquare(squares, k, v);\n        });\n    }\n    return squares;\n}\nfunction addSquare(squares, key, klass) {\n    const classes = squares.get(key);\n    if (classes)\n        squares.set(key, `${classes} ${klass}`);\n    else\n        squares.set(key, klass);\n}\nfunction appendValue(map, key, value) {\n    const arr = map.get(key);\n    if (arr)\n        arr.push(value);\n    else\n        map.set(key, [value]);\n}\n//# sourceMappingURL=render.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/render.js?");

/***/ }),

/***/ "./node_modules/chessground/state.js":
/*!*******************************************!*\
  !*** ./node_modules/chessground/state.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaults: () => (/* binding */ defaults)\n/* harmony export */ });\n/* harmony import */ var _fen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fen.js */ \"./node_modules/chessground/fen.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n\n\nfunction defaults() {\n    return {\n        pieces: _fen_js__WEBPACK_IMPORTED_MODULE_0__.read(_fen_js__WEBPACK_IMPORTED_MODULE_0__.initial),\n        orientation: 'white',\n        turnColor: 'white',\n        coordinates: true,\n        ranksPosition: 'right',\n        autoCastle: true,\n        viewOnly: false,\n        disableContextMenu: false,\n        addPieceZIndex: false,\n        blockTouchScroll: false,\n        pieceKey: false,\n        trustAllEvents: false,\n        highlight: {\n            lastMove: true,\n            check: true,\n        },\n        animation: {\n            enabled: true,\n            duration: 200,\n        },\n        movable: {\n            free: true,\n            color: 'both',\n            showDests: true,\n            events: {},\n            rookCastle: true,\n        },\n        premovable: {\n            enabled: true,\n            showDests: true,\n            castle: true,\n            events: {},\n        },\n        predroppable: {\n            enabled: false,\n            events: {},\n        },\n        draggable: {\n            enabled: true,\n            distance: 3,\n            autoDistance: true,\n            showGhost: true,\n            deleteOnDropOff: false,\n        },\n        dropmode: {\n            active: false,\n        },\n        selectable: {\n            enabled: true,\n        },\n        stats: {\n            // on touchscreen, default to \"tap-tap\" moves\n            // instead of drag\n            dragged: !('ontouchstart' in window),\n        },\n        events: {},\n        drawable: {\n            enabled: true,\n            visible: true,\n            defaultSnapToValidMove: true,\n            eraseOnClick: true,\n            shapes: [],\n            autoShapes: [],\n            brushes: {\n                green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },\n                red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },\n                blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },\n                yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },\n                paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },\n                paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },\n                paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },\n                paleGrey: {\n                    key: 'pgr',\n                    color: '#4a4a4a',\n                    opacity: 0.35,\n                    lineWidth: 15,\n                },\n            },\n            prevSvgHash: '',\n        },\n        hold: (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.timer)(),\n    };\n}\n//# sourceMappingURL=state.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/state.js?");

/***/ }),

/***/ "./node_modules/chessground/svg.js":
/*!*****************************************!*\
  !*** ./node_modules/chessground/svg.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createElement: () => (/* binding */ createElement),\n/* harmony export */   renderSvg: () => (/* binding */ renderSvg),\n/* harmony export */   setAttributes: () => (/* binding */ setAttributes)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n/* harmony import */ var _sync_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sync.js */ \"./node_modules/chessground/sync.js\");\n\n\nfunction createElement(tagName) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\nfunction renderSvg(state, svg, customSvg) {\n    const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : undefined, arrowDests = new Map(), bounds = state.dom.bounds(), nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n    for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n        if (s.dest)\n            arrowDests.set(s.dest, (arrowDests.get(s.dest) || 0) + 1);\n    }\n    const shapes = d.shapes.concat(nonPieceAutoShapes).map((s) => {\n        return {\n            shape: s,\n            current: false,\n            hash: shapeHash(s, arrowDests, false, bounds),\n        };\n    });\n    if (cur)\n        shapes.push({\n            shape: cur,\n            current: true,\n            hash: shapeHash(cur, arrowDests, true, bounds),\n        });\n    const fullHash = shapes.map(sc => sc.hash).join(';');\n    if (fullHash === state.drawable.prevSvgHash)\n        return;\n    state.drawable.prevSvgHash = fullHash;\n    /*\n      -- DOM hierarchy --\n      <svg class=\"cg-shapes\">      (<= svg)\n        <defs>\n          ...(for brushes)...\n        </defs>\n        <g>\n          ...(for arrows and circles)...\n        </g>\n      </svg>\n      <svg class=\"cg-custom-svgs\"> (<= customSvg)\n        <g>\n          ...(for custom svgs)...\n        </g>\n      </svg>\n    */\n    const defsEl = svg.querySelector('defs');\n    const shapesEl = svg.querySelector('g');\n    const customSvgsEl = customSvg.querySelector('g');\n    syncDefs(d, shapes, defsEl);\n    (0,_sync_js__WEBPACK_IMPORTED_MODULE_1__.syncShapes)(shapes.filter(s => !s.shape.customSvg), shapesEl, shape => renderShape(state, shape, d.brushes, arrowDests, bounds));\n    (0,_sync_js__WEBPACK_IMPORTED_MODULE_1__.syncShapes)(shapes.filter(s => s.shape.customSvg), customSvgsEl, shape => renderShape(state, shape, d.brushes, arrowDests, bounds));\n}\n// append only. Don't try to update/remove.\nfunction syncDefs(d, shapes, defsEl) {\n    var _a;\n    const brushes = new Map();\n    let brush;\n    for (const s of shapes) {\n        if (s.shape.dest) {\n            brush = d.brushes[s.shape.brush];\n            if (s.shape.modifiers)\n                brush = makeCustomBrush(brush, s.shape.modifiers);\n            if ((_a = s.shape.modifiers) === null || _a === void 0 ? void 0 : _a.hilite)\n                brushes.set('hilite', { key: 'hilite', color: 'white', opacity: 1, lineWidth: 1 });\n            brushes.set(brush.key, brush);\n        }\n    }\n    const keysInDom = new Set();\n    let el = defsEl.firstChild;\n    while (el) {\n        keysInDom.add(el.getAttribute('cgKey'));\n        el = el.nextSibling;\n    }\n    for (const [key, brush] of brushes.entries()) {\n        if (!keysInDom.has(key))\n            defsEl.appendChild(renderMarker(brush));\n    }\n}\nfunction shapeHash({ orig, dest, brush, piece, modifiers, customSvg }, arrowDests, current, bounds) {\n    return [\n        bounds.width,\n        bounds.height,\n        current,\n        orig,\n        dest,\n        brush,\n        dest && (arrowDests.get(dest) || 0) > 1,\n        piece && pieceHash(piece),\n        modifiers && modifiersHash(modifiers),\n        customSvg && customSvgHash(customSvg),\n    ]\n        .filter(x => x)\n        .join(',');\n}\nfunction pieceHash(piece) {\n    return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\nfunction modifiersHash(m) {\n    return [m.lineWidth, m.hilite].filter(x => x).join(',');\n}\nfunction customSvgHash(s) {\n    // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n    let h = 0;\n    for (let i = 0; i < s.length; i++) {\n        h = ((h << 5) - h + s.charCodeAt(i)) >>> 0;\n    }\n    return 'custom-' + h.toString();\n}\nfunction renderShape(state, { shape, current, hash }, brushes, arrowDests, bounds) {\n    var _a;\n    let el;\n    const orig = orient((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(shape.orig), state.orientation);\n    if (shape.customSvg) {\n        el = renderCustomSvg(shape.customSvg, orig, bounds);\n    }\n    else {\n        if (shape.dest && shape.dest !== shape.orig) {\n            let brush = brushes[shape.brush];\n            if (shape.modifiers)\n                brush = makeCustomBrush(brush, shape.modifiers);\n            el = renderArrow(brush, orig, orient((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(shape.dest), state.orientation), current, (arrowDests.get(shape.dest) || 0) > 1, bounds, (_a = shape.modifiers) === null || _a === void 0 ? void 0 : _a.hilite);\n        }\n        else\n            el = renderCircle(brushes[shape.brush], orig, current, bounds);\n    }\n    el.setAttribute('cgHash', hash);\n    return el;\n}\nfunction renderCustomSvg(customSvg, pos, bounds) {\n    const [x, y] = pos2user(pos, bounds);\n    // Translate to top-left of `orig` square\n    const g = setAttributes(createElement('g'), { transform: `translate(${x},${y})` });\n    // Give 100x100 coordinate system to the user for `orig` square\n    const svg = setAttributes(createElement('svg'), { width: 1, height: 1, viewBox: '0 0 100 100' });\n    g.appendChild(svg);\n    svg.innerHTML = customSvg;\n    return g;\n}\nfunction renderCircle(brush, pos, current, bounds) {\n    const o = pos2user(pos, bounds), widths = circleWidth(), radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n    return setAttributes(createElement('circle'), {\n        stroke: brush.color,\n        'stroke-width': widths[current ? 0 : 1],\n        fill: 'none',\n        opacity: opacity(brush, current),\n        cx: o[0],\n        cy: o[1],\n        r: radius - widths[1] / 2,\n    });\n}\nfunction renderArrow(brush, orig, dest, current, shorten, bounds, hilited = false) {\n    function renderInner(isHilite) {\n        const m = arrowMargin(shorten && !current), a = pos2user(orig, bounds), b = pos2user(dest, bounds), dx = b[0] - a[0], dy = b[1] - a[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;\n        return setAttributes(createElement('line'), {\n            stroke: isHilite ? 'white' : brush.color,\n            'stroke-width': lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n            'stroke-linecap': 'round',\n            'marker-end': `url(#arrowhead-${isHilite ? 'hilite' : brush.key})`,\n            opacity: isHilite ? 1 : opacity(brush, current),\n            x1: a[0],\n            y1: a[1],\n            x2: b[0] - xo,\n            y2: b[1] - yo,\n        });\n    }\n    const el = hilited ? createElement('g') : renderInner(false);\n    if (hilited)\n        [true, false].map(h => el.appendChild(renderInner(h)));\n    return el;\n}\nfunction renderMarker(brush) {\n    const marker = setAttributes(createElement('marker'), {\n        id: 'arrowhead-' + brush.key,\n        orient: 'auto',\n        markerWidth: 4,\n        markerHeight: 8,\n        refX: brush.key === 'hilite' ? 1.86 : 2.05,\n        refY: 2,\n    });\n    marker.appendChild(setAttributes(createElement('path'), {\n        d: 'M0,0 V4 L3,2 Z',\n        fill: brush.color,\n    }));\n    marker.setAttribute('cgKey', brush.key);\n    return marker;\n}\nfunction setAttributes(el, attrs) {\n    for (const key in attrs) {\n        if (Object.prototype.hasOwnProperty.call(attrs, key))\n            el.setAttribute(key, attrs[key]);\n    }\n    return el;\n}\nfunction orient(pos, color) {\n    return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\nfunction makeCustomBrush(base, modifiers) {\n    return {\n        color: base.color,\n        opacity: Math.round(base.opacity * 10) / 10,\n        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n        key: [base.key, modifiers.lineWidth].filter(x => x).join(''),\n    };\n}\nfunction circleWidth() {\n    return [3 / 64, 4 / 64];\n}\nfunction lineWidth(brush, current) {\n    return ((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 64;\n}\nfunction opacity(brush, current) {\n    return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\nfunction arrowMargin(shorten) {\n    return (shorten ? 20 : 10) / 64;\n}\nfunction pos2user(pos, bounds) {\n    const xScale = Math.min(1, bounds.width / bounds.height);\n    const yScale = Math.min(1, bounds.height / bounds.width);\n    return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\n//# sourceMappingURL=svg.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/svg.js?");

/***/ }),

/***/ "./node_modules/chessground/sync.js":
/*!******************************************!*\
  !*** ./node_modules/chessground/sync.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   syncShapes: () => (/* binding */ syncShapes)\n/* harmony export */ });\n// append and remove only. No updates.\nfunction syncShapes(shapes, root, renderShape) {\n    const hashesInDom = new Map(), // by hash\n    toRemove = [];\n    for (const sc of shapes)\n        hashesInDom.set(sc.hash, false);\n    let el = root.firstChild, elHash;\n    while (el) {\n        elHash = el.getAttribute('cgHash');\n        // found a shape element that's here to stay\n        if (hashesInDom.has(elHash))\n            hashesInDom.set(elHash, true);\n        // or remove it\n        else\n            toRemove.push(el);\n        el = el.nextSibling;\n    }\n    // remove old shapes\n    for (const el of toRemove)\n        root.removeChild(el);\n    // insert shapes that are not yet in dom\n    for (const sc of shapes) {\n        if (!hashesInDom.get(sc.hash))\n            root.appendChild(renderShape(sc));\n    }\n}\n//# sourceMappingURL=sync.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/sync.js?");

/***/ }),

/***/ "./node_modules/chessground/types.js":
/*!*******************************************!*\
  !*** ./node_modules/chessground/types.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colors: () => (/* binding */ colors),\n/* harmony export */   files: () => (/* binding */ files),\n/* harmony export */   ranks: () => (/* binding */ ranks)\n/* harmony export */ });\nconst colors = ['white', 'black'];\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/types.js?");

/***/ }),

/***/ "./node_modules/chessground/util.js":
/*!******************************************!*\
  !*** ./node_modules/chessground/util.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allKeys: () => (/* binding */ allKeys),\n/* harmony export */   allPos: () => (/* binding */ allPos),\n/* harmony export */   computeSquareCenter: () => (/* binding */ computeSquareCenter),\n/* harmony export */   createEl: () => (/* binding */ createEl),\n/* harmony export */   distanceSq: () => (/* binding */ distanceSq),\n/* harmony export */   eventPosition: () => (/* binding */ eventPosition),\n/* harmony export */   invRanks: () => (/* binding */ invRanks),\n/* harmony export */   isRightButton: () => (/* binding */ isRightButton),\n/* harmony export */   key2pos: () => (/* binding */ key2pos),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   opposite: () => (/* binding */ opposite),\n/* harmony export */   pos2key: () => (/* binding */ pos2key),\n/* harmony export */   posToTranslate: () => (/* binding */ posToTranslate),\n/* harmony export */   samePiece: () => (/* binding */ samePiece),\n/* harmony export */   setVisible: () => (/* binding */ setVisible),\n/* harmony export */   timer: () => (/* binding */ timer),\n/* harmony export */   translate: () => (/* binding */ translate),\n/* harmony export */   translateAndScale: () => (/* binding */ translateAndScale),\n/* harmony export */   uciToMove: () => (/* binding */ uciToMove)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"./node_modules/chessground/types.js\");\n\nconst invRanks = [..._types_js__WEBPACK_IMPORTED_MODULE_0__.ranks].reverse();\nconst allKeys = Array.prototype.concat(..._types_js__WEBPACK_IMPORTED_MODULE_0__.files.map(c => _types_js__WEBPACK_IMPORTED_MODULE_0__.ranks.map(r => c + r)));\nconst pos2key = (pos) => allKeys[8 * pos[0] + pos[1]];\nconst key2pos = (k) => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];\nconst uciToMove = (uci) => {\n    if (!uci)\n        return undefined;\n    if (uci[1] === '@')\n        return [uci.slice(2, 4)];\n    return [uci.slice(0, 2), uci.slice(2, 4)];\n};\nconst allPos = allKeys.map(key2pos);\nfunction memo(f) {\n    let v;\n    const ret = () => {\n        if (v === undefined)\n            v = f();\n        return v;\n    };\n    ret.clear = () => {\n        v = undefined;\n    };\n    return ret;\n}\nconst timer = () => {\n    let startAt;\n    return {\n        start() {\n            startAt = performance.now();\n        },\n        cancel() {\n            startAt = undefined;\n        },\n        stop() {\n            if (!startAt)\n                return 0;\n            const time = performance.now() - startAt;\n            startAt = undefined;\n            return time;\n        },\n    };\n};\nconst opposite = (c) => (c === 'white' ? 'black' : 'white');\nconst distanceSq = (pos1, pos2) => {\n    const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];\n    return dx * dx + dy * dy;\n};\nconst samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;\nconst posToTranslate = (bounds) => (pos, asWhite) => [((asWhite ? pos[0] : 7 - pos[0]) * bounds.width) / 8, ((asWhite ? 7 - pos[1] : pos[1]) * bounds.height) / 8];\nconst translate = (el, pos) => {\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\nconst translateAndScale = (el, pos, scale = 1) => {\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\nconst setVisible = (el, v) => {\n    el.style.visibility = v ? 'visible' : 'hidden';\n};\nconst eventPosition = (e) => {\n    var _a;\n    if (e.clientX || e.clientX === 0)\n        return [e.clientX, e.clientY];\n    if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0])\n        return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];\n    return; // touchend has no position!\n};\nconst isRightButton = (e) => e.buttons === 2 || e.button === 2;\nconst createEl = (tagName, className) => {\n    const el = document.createElement(tagName);\n    if (className)\n        el.className = className;\n    return el;\n};\nfunction computeSquareCenter(key, asWhite, bounds) {\n    const pos = key2pos(key);\n    if (!asWhite) {\n        pos[0] = 7 - pos[0];\n        pos[1] = 7 - pos[1];\n    }\n    return [\n        bounds.left + (bounds.width * pos[0]) / 8 + bounds.width / 16,\n        bounds.top + (bounds.height * (7 - pos[1])) / 8 + bounds.height / 16,\n    ];\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/util.js?");

/***/ }),

/***/ "./node_modules/chessground/wrap.js":
/*!******************************************!*\
  !*** ./node_modules/chessground/wrap.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   renderWrap: () => (/* binding */ renderWrap)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/chessground/util.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"./node_modules/chessground/types.js\");\n/* harmony import */ var _svg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./svg.js */ \"./node_modules/chessground/svg.js\");\n\n\n\nfunction renderWrap(element, s) {\n    // .cg-wrap (element passed to Chessground)\n    //   cg-container\n    //     cg-board\n    //     svg.cg-shapes\n    //       defs\n    //       g\n    //     svg.cg-custom-svgs\n    //       g\n    //     cg-auto-pieces\n    //     coords.ranks\n    //     coords.files\n    //     piece.ghost\n    element.innerHTML = '';\n    // ensure the cg-wrap class is set\n    // so bounds calculation can use the CSS width/height values\n    // add that class yourself to the element before calling chessground\n    // for a slight performance improvement! (avoids recomputing style)\n    element.classList.add('cg-wrap');\n    for (const c of _types_js__WEBPACK_IMPORTED_MODULE_1__.colors)\n        element.classList.toggle('orientation-' + c, s.orientation === c);\n    element.classList.toggle('manipulable', !s.viewOnly);\n    const container = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('cg-container');\n    element.appendChild(container);\n    const board = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('cg-board');\n    container.appendChild(board);\n    let svg;\n    let customSvg;\n    let autoPieces;\n    if (s.drawable.visible) {\n        svg = (0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.setAttributes)((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('svg'), {\n            class: 'cg-shapes',\n            viewBox: '-4 -4 8 8',\n            preserveAspectRatio: 'xMidYMid slice',\n        });\n        svg.appendChild((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('defs'));\n        svg.appendChild((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('g'));\n        customSvg = (0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.setAttributes)((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('svg'), {\n            class: 'cg-custom-svgs',\n            viewBox: '-3.5 -3.5 8 8',\n            preserveAspectRatio: 'xMidYMid slice',\n        });\n        customSvg.appendChild((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('g'));\n        autoPieces = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('cg-auto-pieces');\n        container.appendChild(svg);\n        container.appendChild(customSvg);\n        container.appendChild(autoPieces);\n    }\n    if (s.coordinates) {\n        const orientClass = s.orientation === 'black' ? ' black' : '';\n        const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n        container.appendChild(renderCoords(_types_js__WEBPACK_IMPORTED_MODULE_1__.ranks, 'ranks' + orientClass + ranksPositionClass));\n        container.appendChild(renderCoords(_types_js__WEBPACK_IMPORTED_MODULE_1__.files, 'files' + orientClass));\n    }\n    let ghost;\n    if (s.draggable.enabled && s.draggable.showGhost) {\n        ghost = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('piece', 'ghost');\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.setVisible)(ghost, false);\n        container.appendChild(ghost);\n    }\n    return {\n        board,\n        container,\n        wrap: element,\n        ghost,\n        svg,\n        customSvg,\n        autoPieces,\n    };\n}\nfunction renderCoords(elems, className) {\n    const el = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('coords', className);\n    let f;\n    for (const elem of elems) {\n        f = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('coord');\n        f.textContent = elem;\n        el.appendChild(f);\n    }\n    return el;\n}\n//# sourceMappingURL=wrap.js.map\n\n//# sourceURL=webpack://website/./node_modules/chessground/wrap.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;